<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android消息机制之handler原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/Android消息机制之handler原理/" class="article-date">
  <time datetime="2019-07-18T13:17:51.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/Android消息机制之handler原理/">Android消息机制之handler原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Android开发中因为UI更新的操作都是在主线程中执行，而网络请求等耗时操作都是在子线程中执行的，因此会遇到很多多线程切换的问题。我们的项目中使用的是RXJava + retrofit，RXJava的observeOn和subcribeOn都能很方便的切换线程。如下形式：<br><code>.observeOn(AndroidSchedulers.mainThread())</code><br>它本质上还是通过handler来实现的。虽然用起来很方便，但是这样对于原理的学习并不是很友好，因此特意学习了下handler原理相关知识。  </p>
<h1 id="一、handler基础知识"><a href="#一、handler基础知识" class="headerlink" title="一、handler基础知识"></a>一、handler基础知识</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><ul>
<li>MainThread(主线程)：也就是UI线程，在程序启动时自动创建。  </li>
<li>工作线程：开发者自己开启的子线程，执行一些耗时操作。  </li>
<li>Handler(处理者)：线程间通信的媒介，一是添加消息到消息队列(Message Queue)，二是处理Looper(循环器)分发的消息。  </li>
<li>Message(消息):Handler处理的对象，存储需要的操作信息。  </li>
<li>Message Queue(消息队列):是一个队列，先进先出，存储Handler发送来的消息。  </li>
<li>Looper: Message Queue和Handler的通信媒介，是一个死循环，不断从Message Queue中取出消息给Handler处理。  </li>
</ul>
<h2 id="2、-对应关系"><a href="#2、-对应关系" class="headerlink" title="2、 对应关系"></a>2、 对应关系</h2><ul>
<li>一个线程(Thread)只能对应一个循环器(Looper)，可理解为一个线程维持一个消息队列(Message Queue)。  </li>
<li>一个线程(Thread)可对应多个处理者(Handler)，可理解为一个消息队列(Message Queue)中的消息可分发给多个处理者(Handler)处理。  </li>
<li>一个循环器(Looper)可对应多个处理者(Handler)。  </li>
<li>一个处理者(Handler)只能对应一个循环器(Looper)，如果对应多个循环器(Looper)，那处理消息会错乱。  </li>
</ul>
<h1 id="二、Handler基本用法"><a href="#二、Handler基本用法" class="headerlink" title="二、Handler基本用法"></a>二、Handler基本用法</h1><h2 id="1、子线程和主线程通信"><a href="#1、子线程和主线程通信" class="headerlink" title="1、子线程和主线程通信"></a>1、子线程和主线程通信</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    Button button;</span><br><span class="line">    Handler handler;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        button = findViewById(R.id.handlerSendMsg);</span><br><span class="line">        button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;  </span><br><span class="line">            //在主线程中创建一个Handler处理子线程发来的消息</span><br><span class="line">                handler = new Handler() &#123;  </span><br><span class="line">                //重写handleMessage方法，这个方法的msg参数就是从子线程传递过来的消息</span><br><span class="line">                    @Override</span><br><span class="line">                    public void handleMessage(Message msg) &#123;  </span><br><span class="line">                    //函数体中就是消息处理的逻辑，可以通过msg.what的消息标识来分别处理不同的消息逻辑</span><br><span class="line">                        Log.d(&quot;mainThread&quot;,&quot;mainThread handleMessage:  &quot; + msg.obj);</span><br><span class="line">                        Toast.makeText(MainActivity.this,&quot;mainThread handleMessage&quot; + msg.obj,Toast.LENGTH_LONG).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                childThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void childThread()&#123;  </span><br><span class="line">     //创建一个子线程</span><br><span class="line">        Thread childThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            //在子线程中通过Handler的obtainMessage获取一个Message的实例</span><br><span class="line">                Message message = handler.obtainMessage();  </span><br><span class="line">                /** </span><br><span class="line">                设置Message的属性  </span><br><span class="line">                Message.what：用来标识信息的int值，通过该值主线程能判断出来自不同地方的信息来源  </span><br><span class="line">                Message.arg1/Message.arg2：Message初始定义的用来传递int类型值的两个变量  </span><br><span class="line">                Message.obj：用来传递任何实例化对象</span><br><span class="line">                */</span><br><span class="line">                message.obj = &quot;childThread message&quot;;</span><br><span class="line">                //通过sendMessage将消息发送出去</span><br><span class="line">                handler.sendMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        childThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、两个子线程通信"><a href="#2、两个子线程通信" class="headerlink" title="2、两个子线程通信"></a>2、两个子线程通信</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    Button button;</span><br><span class="line">    Handler handler;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        button = findViewById(R.id.handlerSendMsg);</span><br><span class="line">        button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                handlerMessageInTwoThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void handlerMessageInTwoThread() &#123;</span><br><span class="line">        Thread firstThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            //在子线程中不调用Looper.prepare()会crash报错，下面会给出分析</span><br><span class="line">                //Looper.prepare();</span><br><span class="line">                handler = new Handler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void handleMessage(Message msg) &#123;</span><br><span class="line">                        Log.d(&quot;firstThread&quot;,&quot;firstThread handleMessage:  &quot; + msg.obj);                      Toast.makeText(MainActivity.this,&quot;firstThread handleMessage&quot; + msg.obj,Toast.LENGTH_LONG).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                //不调用Looper.loop()就收不到消息</span><br><span class="line">                //Looper.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread secondThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Message sendMessage = handler.obtainMessage();</span><br><span class="line">                sendMessage.obj = &quot;secondThread发送的消息&quot;;</span><br><span class="line">                Log.d(&quot;secondThread&quot;,&quot;secondThread sendMessage: &quot; + sendMessage.obj);</span><br><span class="line">                handler.sendMessage(sendMessage);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        firstThread.setName(&quot;firstThread&quot;);</span><br><span class="line">        firstThread.start();</span><br><span class="line">        secondThread.setName(&quot;secondThread&quot;);</span><br><span class="line">        secondThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不打开上面的两行注释代码，和之前的一样，那么运行会报错，报错信息如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...... E/AndroidRuntime: FATAL EXCEPTION: firstThread</span><br><span class="line">    Process: com.example.androidtest, PID: 23777</span><br><span class="line">    java.lang.RuntimeException: Can&apos;t create handler inside thread that has not called Looper.prepare()</span><br><span class="line">        at android.os.Handler.&lt;init&gt;(Handler.java:200)</span><br><span class="line">        at android.os.Handler.&lt;init&gt;(Handler.java:114)</span><br><span class="line">        at com.example.androidtest.MainActivity$3$1.&lt;init&gt;(MainActivity.java:62)</span><br><span class="line">        at com.example.androidtest.MainActivity$3.run(MainActivity.java:62)</span><br></pre></td></tr></table></figure>
<p>意思就是在firstThread中没有调用Looper.prepare()。所以，需要加上Looper.prepare()。不过也可以在firstThread中创建Handler的时候指定一个主线程的Looper。Handler的构造函数是支持带参的，其中一个构造函数如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Use the provided &#123;@link Looper&#125; instead of the default one.</span><br><span class="line">     *</span><br><span class="line">     * @param looper The looper, must not be null.</span><br><span class="line">     */</span><br><span class="line">    public Handler(Looper looper) &#123;</span><br><span class="line">        this(looper, null, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们在firstThread中创建Handler的时候可以这样：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread firstThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //Looper.prepare();  </span><br><span class="line">                //通过Looper.getMainLooper()获取主线程的Looper</span><br><span class="line">                handler = new Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void handleMessage(Message msg) &#123;</span><br><span class="line">                        Log.d(&quot;firstThread&quot;,&quot;firstThread handleMessage:  &quot; + msg.obj);</span><br><span class="line">                        Toast.makeText(MainActivity.this,&quot;firstThread handleMessage&quot; + msg.obj,Toast.LENGTH_LONG).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                //Looper.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>这里就产生了2个问题，第一，为什么主线程中不调用Looper.prepare()可以实现子线程和主线程的通信；第二，Looper.prepare()具体干了什么，为什么不调用就不能在两个子线程中通信。下面的分析主要解决这两个问题。  </p>
<h1 id="三、Handler消息机制分析"><a href="#三、Handler消息机制分析" class="headerlink" title="三、Handler消息机制分析"></a>三、Handler消息机制分析</h1><h2 id="1、主线程为什么不需要调用Looper-prepare"><a href="#1、主线程为什么不需要调用Looper-prepare" class="headerlink" title="1、主线程为什么不需要调用Looper.prepare()"></a>1、主线程为什么不需要调用Looper.prepare()</h2><p>主线程不需要调用Looper.prepare()，那么说明Android程序在启动的时候主线程中就已经做了这部分工作。这里涉及到一个问题就是Android程序的真正入口，就是ActivityThread的main()方法。<a href="https://blog.csdn.net/xu_song/article/details/81983724" target="_blank" rel="noopener">ActivityThread源码分析</a>。查看ActivityThread的main()方法源码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line"></span><br><span class="line">        // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">        // disable it here, but selectively enable it later (via</span><br><span class="line">        // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">        CloseGuard.setEnabled(false);</span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        // Set the reporter for event logging in libcore</span><br><span class="line">        EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">        // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span><br><span class="line">        // It will be in the format &quot;seq=114&quot;</span><br><span class="line">        long startSeq = 0;</span><br><span class="line">        if (args != null) &#123;</span><br><span class="line">            for (int i = args.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">                if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                    startSeq = Long.parseLong(</span><br><span class="line">                            args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        // End of event ActivityThreadMain.</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line">//可见主线程的Looper是不能退出的</span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个函数具体的分析参考上面链接，我们只关注其中和Looper相关的，可以发现有2行：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepareMainLooper();  </span><br><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure>
<p>我们继续看Looper.prepareMainLooper()这个函数里面干了什么  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Initialize the current thread as a looper, marking it as an</span><br><span class="line">     * application&apos;s main looper. The main looper for your application</span><br><span class="line">     * is created by the Android environment, so you should never need</span><br><span class="line">     * to call this function yourself.  See also: &#123;@link #prepare()&#125;</span><br><span class="line">     */</span><br><span class="line">    public static void prepareMainLooper() &#123;</span><br><span class="line">        prepare(false);</span><br><span class="line">        synchronized (Looper.class) &#123;</span><br><span class="line">            if (sMainLooper != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过注释发现就是指定主线程的looper，并且不需要自己调，系统已经做了这部分工作。这里调用的prepare(false)和我们在子线程中调用的Looper.prepare()最终调用的都是一个函数  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Looper.prepare()最终调用的是prepare(true);</span><br><span class="line">    public static void prepare() &#123;</span><br><span class="line">        prepare(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">        if (sThreadLocal.get() != null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以仅有区别就是主线程的不能退出，子线程的可以。  </p>
<h2 id="2、Looper-prepare-做了什么"><a href="#2、Looper-prepare-做了什么" class="headerlink" title="2、Looper.prepare()做了什么"></a>2、Looper.prepare()做了什么</h2><p>不管是主线程还是子线程都必须调用Looper.prepare()，那这个函数具体做了什么呢？其实就一行代码sThreadLocal.set(new Looper(quitAllowed));      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Sets the current thread&apos;s copy of this thread-local variable</span><br><span class="line">     * to the specified value.  Most subclasses will have no need to</span><br><span class="line">     * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class="line">     * method to set the values of thread-locals.</span><br><span class="line">     *</span><br><span class="line">     * @param value the value to be stored in the current thread&apos;s copy of</span><br><span class="line">     *        this thread-local.</span><br><span class="line">     */</span><br><span class="line">    public void set(T value) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的入参是一个Looper，<strong>这个Looper就是当前线程中创建的Looper(new Looper(quitAllowed))存放在了一个ThreadLocal中</strong>。其实在所有线程中创建的Looper都存放在了一个ThreadLocal中。然后在创建Handler的时候就将Handler与当前线程关联。<strong>所以，Looper.prepare()就是将当前线程创建的Looper存放在ThreadLocal中</strong>。<br>下面我们看下是如何关联：<br>例如：handler = new Handler(Looper.getMainLooper()) {…}就是将创建的handler与主线程的Looper关联。<em>我们是可以指定特定的looper，让handleMessage运行在我们想运行的线程中。</em>构造函数如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Looper looper, Callback callback, boolean async) &#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>另外一种handler = new Handler() {…},调用如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Default constructor associates this handler with the &#123;@link Looper&#125; for the</span><br><span class="line">     * current thread.</span><br><span class="line">     *</span><br><span class="line">     * If this thread does not have a looper, this handler won&apos;t be able to receive messages</span><br><span class="line">     * so an exception is thrown.</span><br><span class="line">     */  </span><br><span class="line">     //从上面注释可见如果没有looper就会抛异常，所以需要在之前调用Looper.prepare()创建一个looper</span><br><span class="line">    public Handler() &#123;</span><br><span class="line">        this(null, false);</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    //this(null, false);构造函数源码如下  </span><br><span class="line">    public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">        if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//获取和此线程关联的looper</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        if (mLooper == null) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Can&apos;t create handler inside thread &quot; + Thread.currentThread()</span><br><span class="line">                        + &quot; that has not called Looper.prepare()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    //对应的消息队列</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以在创建handler的时候是通过 mLooper = Looper.myLooper();获取到此线程关联的looper，我们看下 Looper.myLooper()这个函数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Return the Looper object associated with the current thread.  Returns</span><br><span class="line">     * null if the calling thread is not associated with a Looper.</span><br><span class="line">     */</span><br><span class="line">    public static @Nullable Looper myLooper() &#123;</span><br><span class="line">        return sThreadLocal.get();</span><br><span class="line">    &#125;   </span><br><span class="line">      </span><br><span class="line">  //get函数的源码  </span><br><span class="line">public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，就是从ThreadLocal获取关联的looper。真正获取是在get方法里，首先获取当前线程，然后从ThreadLocalMap中取获取和当前线程关联的looper，也就是在当前线程中调用Looper.prepare()时候存储的looper。  </p>
<h1 id="四、消息处理流程"><a href="#四、消息处理流程" class="headerlink" title="四、消息处理流程"></a>四、消息处理流程</h1><p>解决完之前的两个问题，接下来分析消息的处理流程，只有来消息发送、消息获取、消息处理的完整流程走完，才能实现不同线程间的通信。  </p>
<h2 id="1、消息发送"><a href="#1、消息发送" class="headerlink" title="1、消息发送"></a>1、消息发送</h2><p>从handler.sendMessage(sendMessage);一直往里面跟发现最终调用的是MessageQueue.java类中的boolean enqueueMessage(Message msg, long when)函数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;  </span><br><span class="line">//target就是创建的handler</span><br><span class="line">        if (msg.target == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (msg.isInUse()) &#123;</span><br><span class="line">            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = new IllegalStateException(</span><br><span class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            boolean needWake;</span><br><span class="line">            if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">                // New head, wake up the event queue if blocked.</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">                // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">                // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; // invariant: p == prev.next</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">            if (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Message的发送实际是放入到了Handler对应线程的MessageQueue中将Message存到了上一个Message.next上形成了一个链式的列表，同时也保证了Message列表的时序性M通过msg.when保证了时序性。所以，至此发送消息就是将消息存放在消息队列中。  </p>
<h1 id="2、获取消息"><a href="#2、获取消息" class="headerlink" title="2、获取消息"></a>2、获取消息</h1><p>如果不调用Looper.loop();Handler还是会收不到消息，这个方法就是从消息队列中(Message Queue)中获取消息。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;  </span><br><span class="line">//熟悉的味道，在分析handler构造函数的时候也会调用myLooper()获取此线程关联的looper</span><br><span class="line">        final Looper me = myLooper();</span><br><span class="line">        if (me == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">        &#125;  </span><br><span class="line">        //获取Looper对象的消息队列</span><br><span class="line">        final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        // Make sure the identity of this thread is that of the local process,</span><br><span class="line">        // and keep track of what that identity token actually is.</span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        final long ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        // Allow overriding a threshold with a system prop. e.g.</span><br><span class="line">        // adb shell &apos;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&apos;</span><br><span class="line">        final int thresholdOverride =</span><br><span class="line">                SystemProperties.getInt(&quot;log.looper.&quot;</span><br><span class="line">                        + Process.myUid() + &quot;.&quot;</span><br><span class="line">                        + Thread.currentThread().getName()</span><br><span class="line">                        + &quot;.slow&quot;, 0);</span><br><span class="line"></span><br><span class="line">        boolean slowDeliveryDetected = false;</span><br><span class="line">//死循环，从消息队列中一直取消息</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); // might block</span><br><span class="line">            if (msg == null) &#123;</span><br><span class="line">                // No message indicates that the message queue is quitting.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">            final Printer logging = me.mLogging;</span><br><span class="line">            if (logging != null) &#123;</span><br><span class="line">                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                        msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final long traceTag = me.mTraceTag;</span><br><span class="line">            long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">            long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">            if (thresholdOverride &gt; 0) &#123;</span><br><span class="line">                slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">                slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">            &#125;</span><br><span class="line">            final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0);</span><br><span class="line">            final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0);</span><br><span class="line"></span><br><span class="line">            final boolean needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">            final boolean needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">            if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">            final long dispatchEnd;</span><br><span class="line">            try &#123;  </span><br><span class="line">            //分发消息，target就是消息的handler</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (traceTag != 0) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (logSlowDelivery) &#123;</span><br><span class="line">                if (slowDeliveryDetected) &#123;</span><br><span class="line">                    if ((dispatchStart - msg.when) &lt;= 10) &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;Drained&quot;);</span><br><span class="line">                        slowDeliveryDetected = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;,</span><br><span class="line">                            msg)) &#123;</span><br><span class="line">                        // Once we write a slow delivery log, suppress until the queue drains.</span><br><span class="line">                        slowDeliveryDetected = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (logSlowDispatch) &#123;</span><br><span class="line">                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (logging != null) &#123;</span><br><span class="line">                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Make sure that during the course of dispatching the</span><br><span class="line">            // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">            final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            if (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                        + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                        + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                        + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>整个流程就是首先获取当前线程的Looper对象，然后获取Looper对象的消息队列，最后开启一个死循环，不断从消息队列中获取消息，通过消息的handler分发消息msg.target.dispatchMessage(msg)。下面看下Handler类中的这个函数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  * Handle system messages here.</span><br><span class="line">  */</span><br><span class="line"> public void dispatchMessage(Message msg) &#123;</span><br><span class="line">     if (msg.callback != null) &#123;</span><br><span class="line">         handleCallback(msg);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         if (mCallback != null) &#123;</span><br><span class="line">             if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         handleMessage(msg);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数调用handleCallback(msg)或者handleMessage(msg)处理消息。  </p>
<h2 id="3、消息处理"><a href="#3、消息处理" class="headerlink" title="3、消息处理"></a>3、消息处理</h2><p>本例中我们没有设置callback，所以直接调用的是handleMessage(msg)这个函数。也就是我们在创建handler的时候复写的方法。但是这儿有个handleCallback(msg)方法。<br>查了下资料发现这个是由于Handler发送消息的方式导致有两种方式处理消息。如果我们使用sendMessage方式发送消息，则callback为空，即回调我们复写的handleMessage方法。二另外一种方式发送消息就是post(Runnable r)方法发送消息，就会回调runnable中复写的run方法。修改我们demo中的代码使用post方法发送消息。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void handlerMessageInTwoThread() &#123;</span><br><span class="line">        Thread firstThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Looper.prepare();</span><br><span class="line">                handler = new Handler();</span><br><span class="line">                Looper.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread secondThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                final Message sendMessage = handler.obtainMessage();</span><br><span class="line">                sendMessage.obj = &quot;secondThread发送的消息&quot;;</span><br><span class="line">                Log.d(&quot;secondThread&quot;,&quot;secondThread sendMessage: &quot; + sendMessage.obj);</span><br><span class="line">                //handler.sendMessage(sendMessage);</span><br><span class="line">                handler.post(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        Toast.makeText(MainActivity.this,&quot;firstThread handleMessage&quot; + sendMessage.obj,Toast.LENGTH_LONG).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        firstThread.setName(&quot;firstThread&quot;);</span><br><span class="line">        firstThread.start();</span><br><span class="line">        secondThread.setName(&quot;secondThread&quot;);</span><br><span class="line">        secondThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在firstThread中创建了handler，并没有复写handleMessage。而是在secondThread中使用post方式发送消息并复写了Runnable的run方法来执行我们需要执行的逻辑。  </p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>总结一下，其实Handler机制并没有想象中的复杂，主要就是handler、message、message queue、looper。  </p>
<ul>
<li>handler就是对消如果在主线程中创建handler，那么这个handler就和主线程的looper关联了。如果在子线程中创建handler，就需要先调用Looper.prepare()存储此线程的Looper，然后new Handler的时候关联。当然也可以在new Handler的指定关联的looper。  </li>
<li>message就是存储传递消息的属性。  </li>
<li>message queue就是存储发送的消息，是一个链式的列表。  </li>
<li>looper就是从message queue中取出消息给handler处理。  </li>
</ul>
<p>当然handler消息机制中涉及的问题很多，例如内存泄露问题、 ThreadLocal保证线程looper的实现、Android主线程(ActivityThread)问题，这些后续陆续补充。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/18/Android消息机制之handler原理/" data-id="cjyedanxl001hey6c0ufavjji" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网上资料链接" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/04/网上资料链接/" class="article-date">
  <time datetime="2019-07-04T07:38:15.000Z" itemprop="datePublished">2019-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/04/网上资料链接/">网上资料链接</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、Java"><a href="#一、Java" class="headerlink" title="一、Java"></a>一、Java</h1><p>effective java第三版中文翻译：<a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/README" target="_blank" rel="noopener">第三版中文翻译</a><br>计算机基础、java相关知识合集：<a href="https://github.com/PansonPanson/Java-Notes" target="_blank" rel="noopener">合集</a>  </p>
<h1 id="二、Android"><a href="#二、Android" class="headerlink" title="二、Android"></a>二、Android</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/04/网上资料链接/" data-id="cjyedanx20011ey6cv6y0hi6f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/使用指南/">使用指南</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-inflate导致的空指针" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/28/inflate导致的空指针/" class="article-date">
  <time datetime="2019-06-28T11:29:27.000Z" itemprop="datePublished">2019-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/28/inflate导致的空指针/">inflate导致的空指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在一个项目开发中遇到一个手残的问题，但是排查的时候觉得很坑爹，就记录下加深记忆。  </p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某次开发中有个折叠框的小需求，点击的时候展开，通过动态添加item来实现，每个item上有个分割线，很简单。开发完后编译没问题，但是一运行就崩。  </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><pre><code>contentListLayout.removeAllViews();
        LayoutInflater layoutInflater = LayoutInflater.from(getContext());
        for (CharSequence content : contentList) {
            View viewContent = layoutInflater.inflate(R.layout.layout_collapse_content_item, null);
            tvContent = viewContent.findViewById(R.id.tvContent);
            tvContent.setText(content);
            tvContent.setTextColor(Color.parseColor(contentColor));
            tvContent.setTextSize(contentSize);
            contentListLayout.addView(viewContent);
        }
</code></pre><h2 id="item-xml代码"><a href="#item-xml代码" class="headerlink" title="item xml代码"></a>item xml代码</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;    
    &lt;view
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0.5dp&quot;
        android:background=&quot;@color/divideLineColor&quot;/&gt;
    &lt;TextView
        android:id=&quot;@+id/tvContent&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;我是内容文字&quot;
        android:paddingBottom=&quot;13dp&quot;
        android:paddingTop=&quot;13dp&quot;
        android:textSize=&quot;14sp&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><h1 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h1><p>编译的时候不会报错，运行时报错信息如下：<br>android.view.InflateException: Binary XML file  …</p>
<h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><p>从报错信息中可见是在我们inflate的时候空指针了，资源文件名都没问题。最终查看xml文件里面的时候发现分割线的view写成小写了，导致崩溃。<br>这里的问题就在于view的v写成小写AS并不会报错，只有在运行时才崩溃，所以排查起来很坑爹。<br>总结：不要手残。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/28/inflate导致的空指针/" data-id="cjyedanwf0003ey6cm9e4hiql" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/问题总结/">问题总结</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hexo使用指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/07/hexo使用指南/" class="article-date">
  <time datetime="2018-12-07T08:56:42.000Z" itemprop="datePublished">2018-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/07/hexo使用指南/">hexo使用指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、hexo安装和使用"><a href="#1、hexo安装和使用" class="headerlink" title="1、hexo安装和使用"></a>1、hexo安装和使用</h1><p><a href="https://www.jianshu.com/p/e5f95eb990ad" target="_blank" rel="noopener">参考链接</a></p>
<h1 id="2、hexo的-config-yml的配置"><a href="#2、hexo的-config-yml的配置" class="headerlink" title="2、hexo的_config.yml的配置"></a>2、hexo的_config.yml的配置</h1><pre><code>deploy:
  type: git
  repository: git@github.com:username/username.github.io.git
  branch: master
</code></pre><p>如果报错 deploy的时候<br><code>error deployer not found: git</code><br>在hexo目录下执行<br><code>npm install hexo-deployer-git --save</code><br>然后在部署就OK.<br>deploy之前可以先执行<br><code>hexo clean</code><br>清楚缓存  </p>
<h1 id="3、新的电脑如何使用"><a href="#3、新的电脑如何使用" class="headerlink" title="3、新的电脑如何使用"></a>3、新的电脑如何使用</h1><p>按照1和2之后，在一个目录下执行<br><code>hexo init</code></p>
<p>就会从2设置的repository地址中拉取。<br>之后就和1中的使用一样了。  </p>
<h1 id="4、关于上传本地图片"><a href="#4、关于上传本地图片" class="headerlink" title="4、关于上传本地图片"></a>4、关于上传本地图片</h1><p><a href="https://blog.csdn.net/hqweay/article/details/80847495" target="_blank" rel="noopener">参考链接</a>不起作用，有进展在同步。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/07/hexo使用指南/" data-id="cjyedanwb0001ey6cobcy8vx8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/使用指南/">使用指南</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/07/hello-world/" class="article-date">
  <time datetime="2018-12-07T08:40:52.707Z" itemprop="datePublished">2018-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/07/hello-world/">hexo基本操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/07/hello-world/" data-id="cjyedanw70000ey6ck2ktg3mi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/使用指南/">使用指南</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-六、Material Design" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/22/六、Material Design/" class="article-date">
  <time datetime="2018-06-22T06:24:40.000Z" itemprop="datePublished">2018-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/22/六、Material Design/">六、Material Design</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Material Design是2014年在Google I/O大会上推出的一套全新的界面设计语言。它基于传统优秀的设计原则，结合了丰富的创意和科学技术，包含了视觉、运动、互动效果等特性。</p>
<h1 id="1、Toolbar"><a href="#1、Toolbar" class="headerlink" title="1、Toolbar"></a>1、Toolbar</h1><p>Toolbar是一个Material控件，具有灵活和美观的特点。可以配合其他控件完成一些Material Design效果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/22/六、Material Design/" data-id="cjyedanww000pey6cuvs81zci" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-三(1)、ListView和RecycleView" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/19/三(1)、ListView和RecycleView/" class="article-date">
  <time datetime="2018-06-19T12:45:07.000Z" itemprop="datePublished">2018-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/19/三(1)、ListView和RecycleView/">三(1)、ListView和RecyclerView</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、ListView"><a href="#1、ListView" class="headerlink" title="1、ListView"></a>1、ListView</h1><p>程序中有大量数据需要展示的时候就可以借助ListView来实现，ListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕。  </p>
<h2 id="1-1ListView简单用法"><a href="#1-1ListView简单用法" class="headerlink" title="1.1ListView简单用法"></a>1.1ListView简单用法</h2><p>新建ListViewTest项目，修改activity_main.xml代码,在布局中加入ListView控件：  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
tools:context=&quot;.MainActivity&quot;&gt;

&lt;ListView
    android:id=&quot;@+id/list_view&quot;    //指定id
    android:layout_width=&quot;match_parent&quot;    //占满整个布局空间
    android:layout_height=&quot;match_parent&quot;&gt;&lt;/ListView&gt;

&lt;/android.support.constraint.ConstraintLayout&gt;
</code></pre><p>修改MainActivity中的代码：  </p>
<pre><code>package com.example.xxxxx.listviewtest;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.widget.ArrayAdapter;
import android.widget.ListView;

public class MainActivity extends AppCompatActivity {

    private String[] data = {&quot;Apple&quot; , &quot;Banana&quot; , &quot;Orange&quot; , &quot;Watermelon&quot; , &quot;Pear&quot; ,&quot;Grape&quot; ,
           &quot;Pineapple&quot; , &quot;Strawberry&quot; , &quot;Cherry&quot; , &quot;Mango&quot; ,&quot;Apple&quot; , &quot;Banana&quot; , &quot;Orange&quot; ,
        &quot;Watermelon&quot; , &quot;Pear&quot; ,&quot;Grape&quot; , &quot;Pineapple&quot; , &quot;Strawberry&quot; , &quot;Cherry&quot; , &quot;Mango&quot;};

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    //数组中的数据无法直接传递给ListView，需要借助适配器完成，此处使用ArrayAdapter
    //通过泛型指定要适配的数控类型，然后在构造函数中传入要适配的数据
    ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(MainActivity.this,android.R.layout.simple_list_item_1,data);

    ListView listView = (ListView)findViewById(R.id.list_view);
    //将构建好的适配器对象传递进去，使ListView和数据之间建立关联
    listView.setAdapter(adapter);
}
}
</code></pre><p>ArrayAdapter的构造函数中依次传入当前上下文、ListView子项布局的id，以及要适配的数据。使用android.R.layout.simple_list_item_1作为ListView子项布局的id，这是一个Android内置的布局文件，里面只有一个TextView，可用于简单地显示一段文本。  </p>
<h2 id="1-2定制ListView的界面"><a href="#1-2定制ListView的界面" class="headerlink" title="1.2定制ListView的界面"></a>1.2定制ListView的界面</h2><p>让它显示更加丰富的内容，不仅仅是一段文本。为水果配置图片。<br>新建一个实体类Fruit，作为ListView适配器的适配类型。代码如下：  </p>
<pre><code>package com.example.xxxxxxxxxx.listviewtest;
public class Fruit {
    private String name;
    private  int imageId;

public Fruit(String name , int imageId){
    this.name = name;
    this.imageId = imageId;
}

public String getName(){
    return name;
}
public int getImageId(){
    return imageId;
}
}
</code></pre><p>name表示水果的名字，imageId表示水果对应图片的资源id。<br>然后需要为ListView的子项指定一个我们自定义的布局，在layout目录下新建fruit_item.xml，代码如下：  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.constraint.ConstraintLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; 
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

&lt;ImageView
    android:id=&quot;@+id/fruit_image&quot;
    android:layout_width=&quot;60dp&quot;
    android:layout_height=&quot;60dp&quot; /&gt;

&lt;TextView
    android:id=&quot;@+id/fruit_name&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot; 
    android:layout_gravity = &quot;center_vertical&quot;  //垂直居中显示
    android:layout_marginLeft=&quot;10dp&quot;/&gt;

&lt;/android.support.constraint.ConstraintLayout&gt;
</code></pre><p>接下来需要创建一个自定义的适配器，这个适配器继承自ArrayAdapter，并将泛型指定为Fruit。新建FruitAdapter，代码如下：  </p>
<pre><code>package com.example.xxxxx.listviewtest;

import android.content.Context;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.TextView;
import java.util.List;

public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; {
    private int resourceId;
    //重写父类的一组构造函数，用于将上下文、ListView子项布局id和数据传递进来。
    public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt;objects){
        super(context, textViewResourceId, objects);
        resourceId = textViewResourceId;
    }

@Override
//重写getView方法，在每个子项被滚动到屏幕的时候就会被调用此方法
public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
    //获取当前项的Fruit实例
    Fruit fruit = getItem(position);
    //使用LayoutInflater为每个子项加载我们传入的布局
    //第三个参数false表示只让我们在父布局中声明的layout属性生效，不为这个view添加父布局，因为一旦添加父布局
    //之后，它就不能再添加到ListView中了（ListView的标准写法）
    View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);

    //获取ImageView和TextView的实例
    ImageView fruitImage = (ImageView)view.findViewById(R.id.fruit_image);
    TextView fruitName = (TextView)view.findViewById(R.id.fruit_name);
    //设置显示的图片和文字
    fruitImage.setImageResource(fruit.getImageId());
    fruitName.setText(fruit.getName());
    return view;  //返回布局
}
}
</code></pre><p>修改MainActivity中的代码：  </p>
<pre><code>package com.example.xxxxx.listviewtest;

import android.support.annotation.Nullable;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import java.util.ArrayList;
import java.util.List;

public class MainActivity extends AppCompatActivity {

    private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;();

@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    //初始化水果数据
    initFruits();

    //构建FruitAdapter对象，并将FruitAdapter作为适配器传递给ListView。
    FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList);
    ListView listView = (ListView)findViewById(R.id.list_view);
    listView.setAdapter(adapter);
}

//初始化水果数据，传入水果的名字和图片id，并将对象添加到水果列表中。
private void initFruits(){
    for (int i = 0; i&lt;2; i++){
        Fruit apple = new Fruit(&quot;Apple&quot;,R.drawable.apple_pic);
        fruitList.add(apple);
        Fruit banana = new Fruit(&quot;Banana&quot;, R.drawable.banana_pic);
        fruitList.add(banana);
        Fruit orange = new Fruit(&quot;Orange&quot;,R.drawable.orange_pic);
        fruitList.add(orange);
        Fruit watermelon = new Fruit(&quot;Watermelon&quot;, R.drawable.watermelon_pic);
        fruitList.add(watermelon);
        Fruit pear = new Fruit(&quot;Pear&quot;,R.drawable.pear_pic);
        fruitList.add(pear);
        Fruit grape = new Fruit(&quot;Grape&quot;, R.drawable.grape_pic);
        fruitList.add(grape);
        Fruit pineapple = new Fruit(&quot;Pineapple&quot;, R.drawable.pineapple_pic);
        fruitList.add(pineapple);
        Fruit strawberry = new Fruit(&quot;Strawberry&quot;, R.drawable.strawberry_pic);
        fruitList.add(strawberry);
        Fruit cherry = new Fruit(&quot;Cherry&quot;, R.drawable.cherry_pic);
        fruitList.add(cherry);
        Fruit mango = new Fruit(&quot;Mango&quot;, R.drawable.mango_pic);
        fruitList.add(mango);
    }
}
}
</code></pre><h2 id="1-3ListView的点击事件"><a href="#1-3ListView的点击事件" class="headerlink" title="1.3ListView的点击事件"></a>1.3ListView的点击事件</h2><p>ListView如何响应用户的点击事件，修改MainActivity中代码：  </p>
<pre><code>...
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    //初始化水果数据
    initFruits();

    //构建FruitAdapter对象，并将FruitAdapter作为适配器传递给ListView。
    FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList);
    ListView listView = (ListView)findViewById(R.id.list_view);
    listView.setAdapter(adapter);
    //响应点击事件
    listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
        @Override
        public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
            Fruit fruit = fruitList.get(position);
            Toast.makeText(MainActivity.this, fruit.getName(),Toast.LENGTH_SHORT).show();
        }
    });
}
...
</code></pre><h1 id="2、RecyclerView"><a href="#2、RecyclerView" class="headerlink" title="2、RecyclerView"></a>2、RecyclerView</h1><p>新建RecyclerView项目。  </p>
<h2 id="2-1RecyclerView基本用法"><a href="#2-1RecyclerView基本用法" class="headerlink" title="2.1RecyclerView基本用法"></a>2.1RecyclerView基本用法</h2><p>ReyclerView也属于新增的控件，为了让RecyclerView在所有Android版本上都能使用，将其定义在support库中。在app/build.gradle文件中添加：  </p>
<pre><code>dependencies {
implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
implementation &apos;com.android.support:appcompat-v7:27.1.1&apos;
implementation &apos;com.android.support.constraint:constraint-layout:1.1.0&apos;
testImplementation &apos;junit:junit:4.12&apos;
androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos;
androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;
implementation &apos;com.android.support:recyclerview-v7:27.1.1&apos;  //添加内容
}
</code></pre><p>点击Sync Now进行同步。 修改activity_main.xml中的代码：  </p>
<pre><code>&lt;android.support.v7.widget.RecyclerView  //添加RecyclerView控件
    android:id=&quot;@+id/recycler_view&quot;
        android:layout_height=&quot;match_parent&quot;
    android:layout_width=&quot;match_parent&quot; /&gt;
</code></pre><p>新建Fruit类和fruit_item.xml都和ListViewTest的一样。<br>然后为RecyclerView准备一个适配器，新建FruitAdapter类，让这个适配器继承自RecyclerView.Adapter，并将泛型指定为FruitAdapter.ViewHolder。ViewHolder是在FruitAdapter中定义的一个内部类。准备适配器代码如下：  </p>
<pre><code>package com.example.xxxxx.recyclerview;

import android.support.annotation.NonNull;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;
import java.util.List;

public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; {
    private List&lt;Fruit&gt; mFruitList;

//定义一个内部类，继承RecyclerView.ViewHolder
static class ViewHolder extends RecyclerView.ViewHolder{
    ImageView fruitImage;
    TextView fruitName;

    //构造函数的参数view就是RecyclerView子项的最外层布局，然后就可以获取ImageView和TextView实例
    public ViewHolder(View view){
        super(view);
        fruitImage = (ImageView)view.findViewById(R.id.fruit_image);
        fruitName = (TextView)view.findViewById(R.id.fruit_name);
    }
}

//构造函数用于将要展示的数据源传进来，并赋值给全局变量，方便后续对其操作
public FruitAdapter(List&lt;Fruit&gt; fruitList){
    mFruitList = fruitList;
}

//继承自RecyclerView.ViewHolder就必须冲写这三个方法
@Override
//将fruit_item加载进来，然后创建一个ViewHolder实例
public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
    View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false);
    ViewHolder holder = new ViewHolder(view);
    return  holder;
}

//对RecyclerView子项的数据进行赋值，在每个子项滚动到屏幕内的时候执行，通过position参数得到当前的fruit实例
@Override
public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
    Fruit fruit = mFruitList.get(position);
    holder.fruitImage.setImageResource(fruit.getImageId());
    holder.fruitName.setText(fruit.getName());
}

//RecyclerView一共有多少子项
@Override
public int getItemCount() {
    return mFruitList.size();
}
}
</code></pre><p>  准备好适配器之后就可以使用RecyclerView，修改MainActivity中代码：  </p>
<pre><code>package com.example.xxxxx.recyclerview;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import java.util.ArrayList;
import java.util.List;

public class MainActivity extends AppCompatActivity {

private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;();

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    initFruits();
    //获取RecyclerView实例
    RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recycler_view);

    //LinearLayoutManager是线性布局的意思，实现和ListView类似的效果
    LinearLayoutManager layoutManager = new LinearLayoutManager(this);
    recyclerView.setLayoutManager(layoutManager);
    FruitAdapter adapter = new FruitAdapter(fruitList);
    recyclerView.setAdapter(adapter);
}

//初始化水果数据，传入水果的名字和图片id，并将对象添加到水果列表中。
private void initFruits(){
    for (int i = 0; i&lt;3; i++){
        Fruit apple = new Fruit(&quot;Apple&quot;,R.drawable.apple_pic);
        fruitList.add(apple);
        Fruit banana = new Fruit(&quot;Banana&quot;, R.drawable.banana_pic);
        fruitList.add(banana);
        Fruit orange = new Fruit(&quot;Orange&quot;,R.drawable.orange_pic);
        fruitList.add(orange);
        Fruit watermelon = new Fruit(&quot;Watermelon&quot;, R.drawable.watermelon_pic);
        fruitList.add(watermelon);
        Fruit pear = new Fruit(&quot;Pear&quot;,R.drawable.pear_pic);
        fruitList.add(pear);
        Fruit grape = new Fruit(&quot;Grape&quot;, R.drawable.grape_pic);
        fruitList.add(grape);
        Fruit pineapple = new Fruit(&quot;Pineapple&quot;, R.drawable.pineapple_pic);
        fruitList.add(pineapple);
        Fruit strawberry = new Fruit(&quot;Strawberry&quot;, R.drawable.strawberry_pic);
        fruitList.add(strawberry);
        Fruit cherry = new Fruit(&quot;Cherry&quot;, R.drawable.cherry_pic);
        fruitList.add(cherry);
        Fruit mango = new Fruit(&quot;Mango&quot;, R.drawable.mango_pic);
        fruitList.add(mango);
    }
}
}  
</code></pre><h2 id="2-2实现横向滚动"><a href="#2-2实现横向滚动" class="headerlink" title="2.2实现横向滚动"></a>2.2实现横向滚动</h2><p>修改fruit_item布局，目前这个布局里面的元素是水平排列的，适用于纵向滚动的场景，如果要实现横向滚动，应该把fruit_item里的元素改成垂直排列才合理。修改fruit_item.xml中的代码：  </p>
<pre><code>&lt;LinearLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot;
android:layout_width=&quot;100dp&quot;
android:layout_height=&quot;wrap_content&quot;&gt;

&lt;ImageView
android:id=&quot;@+id/fruit_image&quot;
android:layout_width=&quot;50dp&quot;
android:layout_height=&quot;50dp&quot;
android:layout_gravity=&quot;center_horizontal&quot;/&gt;
&lt;TextView
android:id=&quot;@+id/fruit_name&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_gravity=&quot;center_horizontal&quot;
android:layout_marginTop=&quot;10dp&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre><p>将LinearLayout改成垂直方向排列，并把宽度设置为100dp。将ImageView和TextView设置成在布局中水平居中，使用layout_marginTop属性让文字和图片直接保持一些距离。<br>修改MainActivity中的代码：  </p>
<pre><code>...
public class MainActivity extends AppCompatActivity {

private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;();

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    initFruits();
    //获取RecyclerView实例
    RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recycler_view);

    //LinearLayoutManager是线性布局的意思，实现和ListView类似的效果
    LinearLayoutManager layoutManager = new LinearLayoutManager(this);
    //recyclerView.setLayoutManager(layoutManager);
    //FruitAdapter adapter = new FruitAdapter(fruitList);
    //实现横向滚动
    layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
    recyclerView.setLayoutManager(layoutManager);
    FruitAdapter adapter = new FruitAdapter(fruitList);
    recyclerView.setAdapter(adapter);
}
}
</code></pre><h2 id="2-3其它布局"><a href="#2-3其它布局" class="headerlink" title="2.3其它布局"></a>2.3其它布局</h2><p>除了LinearLayoutManager之外，RecyclerView还提供了GridLayoutManager和StaggeredGridLayoutManager这两种内置的布局排列方式。GridLayoutManager可以用于实现网络布局，StaggeredGridLayoutManager可以用于实现瀑布流布局。  </p>
<h2 id="2-4RecyclerView的点击事件"><a href="#2-4RecyclerView的点击事件" class="headerlink" title="2.4RecyclerView的点击事件"></a>2.4RecyclerView的点击事件</h2><p>RecyclerView的所有点击事件都是由具体的View去注册的。在RecyclerView中注册点击事件，首先修改FruitAdapter中的代码：  </p>
<pre><code>public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; {
    private List&lt;Fruit&gt; mFruitList;

//定义一个内部类，继承RecyclerView.ViewHolder
static class ViewHolder extends RecyclerView.ViewHolder{
    View fruitView;  //新增代码
    ImageView fruitImage;
    TextView fruitName;

    //构造函数的参数view就是RecyclerView子项的最外层布局，然后就可以获取ImageView和TextView实例
    public ViewHolder(View view){
        super(view);
        fruitView = view; //新增代码
        fruitImage = (ImageView)view.findViewById(R.id.fruit_image);
        fruitName = (TextView)view.findViewById(R.id.fruit_name);
    }
}

//构造函数用于将要展示的数据源传进来，并赋值给全局变量，方便后续对其操作
public FruitAdapter(List&lt;Fruit&gt; fruitList){
    mFruitList = fruitList;
}

//继承自RecyclerView.ViewHolder就必须冲写这三个方法
@Override
//将fruit_item加载进来，然后创建一个ViewHolder实例
public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
    View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false);

    //新增代码
    final ViewHolder holder = new ViewHolder(view);
    //ViewHolder holder = new ViewHolder(view);
    holder.fruitView.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            int position = holder.getAdapterPosition();
            Fruit fruit = mFruitList.get(position);
            Toast.makeText(v.getContext(),&quot;you clicked view&quot;+fruit.getName(),Toast.LENGTH_SHORT).show();
        }
    });
    return  holder;
}

//对RecyclerView子项的数据进行赋值，在每个子项滚动到屏幕内的时候执行，通过position参数得到当前的fruit实例
@Override
public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
    Fruit fruit = mFruitList.get(position);
    holder.fruitImage.setImageResource(fruit.getImageId());
    holder.fruitName.setText(fruit.getName());
}

//RecyclerView一共有多少子项
@Override
public int getItemCount() {
    return mFruitList.size();
}
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/19/三(1)、ListView和RecycleView/" data-id="cjyedanxi001fey6cx54yd92z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-五、内容提供器(Content Provider)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/07/五、内容提供器(Content Provider)/" class="article-date">
  <time datetime="2018-06-07T13:41:00.000Z" itemprop="datePublished">2018-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/07/五、内容提供器(Content Provider)/">五、内容提供器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="五、内容提供器"><a href="#五、内容提供器" class="headerlink" title="五、内容提供器"></a>五、内容提供器</h1><p>内容提供器(Content Provider)主要用于在不同的应用程序之间实现数据的共享功能，它提供了一套完整的机制，允许一个程序访问另外一个程序中的数据，同时还能有效保证被访问数据的安全性。是Android实现跨程序共享数据的标准方式。    </p>
<h2 id="1、运行时权限"><a href="#1、运行时权限" class="headerlink" title="1、运行时权限"></a>1、运行时权限</h2><h3 id="1-1Android权限机制详解"><a href="#1-1Android权限机制详解" class="headerlink" title="1.1Android权限机制详解"></a>1.1Android权限机制详解</h3><p>访问系统的网络状态以及监听开机广播，在AndroidManifest.xml中添加权限声明：  </p>
<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.example.xxxxx.broadcasttest&quot;&gt;

&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;  //访问网络状态权限声明
   &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;  //监听开机广播权限声明
&lt;/manifest&gt;
</code></pre><p>访问系统的网络状态和监听开机广播涉及到用户设备的安全性，因此必须在AndroidManifest.xml中加入权限声明，否则程序会崩溃。<br>常用软件普遍存在滥用权限的情况，不管到底用不用得到先把权限申请了再说。所有Android开发团队从6.0系统加入了运行时权限功能。<br>Android现在的所有权限分为两类，普通权限和危险权限。普通权限是安心不会直接威胁到用户的安全和隐私的权限，系统会帮我们进行授权，不需要用户操作。危险权限则表示哪些可能会触及用户隐私或对社保安全性造成影响的权限，如获取设备联系人、定位设备的地理位置等，这些需要用户手动点击授权，否则程序无法使用相应的功能。  </p>
<table>
<thead>
<tr>
<th style="text-align:left">权限组名</th>
<th style="text-align:center">权限名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CALENDAR</td>
<td style="text-align:center">READ_CALENDAR</td>
</tr>
<tr>
<td style="text-align:left">CALENDAR</td>
<td style="text-align:center">WRITE_CALENDAR</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">CAMERA</td>
<td style="text-align:center">CAMERA</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">CONTACTS</td>
<td style="text-align:center">READ_CONTACTS</td>
</tr>
<tr>
<td style="text-align:left">CONTACTS</td>
<td style="text-align:center">WRITE_CONTACTS</td>
</tr>
<tr>
<td style="text-align:left">CONTACTS</td>
<td style="text-align:center">GET_CONTACTS</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">LOCATION</td>
<td style="text-align:center">ACCESS_FINE_LOCATION</td>
</tr>
<tr>
<td style="text-align:left">LOCATION</td>
<td style="text-align:center">ACCESS_COARSE_LOCATION</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">MICROPHONE</td>
<td style="text-align:center">RECORD_AUDIO</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">READ_PHONE_STATE</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">CALL_PHONE</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">READ_CALL_LOG</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">WRITE_CALL_STATE</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">ADD_VOICEMAIL</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">USE_SIP</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">PROCESS_OUTGOING_CALLS</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">SENSORS</td>
<td style="text-align:center">BODY_SENSORS</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">SMS</td>
<td style="text-align:center">SEND_SMS</td>
</tr>
<tr>
<td style="text-align:left">SMS</td>
<td style="text-align:center">RECEIVE_SMS</td>
</tr>
<tr>
<td style="text-align:left">SMS</td>
<td style="text-align:center">READ_SMS</td>
</tr>
<tr>
<td style="text-align:left">SMS</td>
<td style="text-align:center">RECEIVE_WAP_SMS</td>
</tr>
<tr>
<td style="text-align:left">SMS</td>
<td style="text-align:center">RECEIVE_MMS</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">STORAGE</td>
<td style="text-align:center">READ_EXTERNAL_STORAGE</td>
</tr>
<tr>
<td style="text-align:left">STORAGE</td>
<td style="text-align:center">WRITE_EXTERNAL_STORAGE</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
</tbody>
</table>
<p>使用权限时，如果属于这张表的权限，就需要进行运行时权限处理，如果不在这样表中那么只需要在AndroidManifest.xml文件中添加一下权限声明就可以。<br>权限处理时处理的是权限名，但是用户授权后对应的权限组中其他的权限也会同时被授权。  </p>
<h3 id="1-2运行时权限申请（262页）"><a href="#1-2运行时权限申请（262页）" class="headerlink" title="1.2运行时权限申请（262页）"></a>1.2运行时权限申请（262页）</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/07/五、内容提供器(Content Provider)/" data-id="cjyedanwr000hey6cy3im65ba" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-四、广播" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/06/四、广播/" class="article-date">
  <time datetime="2018-06-06T03:11:06.000Z" itemprop="datePublished">2018-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/06/四、广播/">四、广播</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="四、广播"><a href="#四、广播" class="headerlink" title="四、广播"></a>四、广播</h1><p>Android中广播的两种类型：标准广播和有序广播<br><strong>标准广播：</strong>异步执行的广播，广播发出后广播接收器几乎同时接收者条广播信息，没有先后顺序。这种广播效率高，但是无法被截断。<br><strong>有序广播：</strong>同步执行的广播，广播发出后同一时刻只会有一个广播接收器接收到这条广播消息，逻辑执行完毕后广播才继续传递。前面的广播接收器可以截断正在传递的广播。  </p>
<h2 id="1、接收系统广播"><a href="#1、接收系统广播" class="headerlink" title="1、接收系统广播"></a>1、接收系统广播</h2><p>要接收广播就需要使用广播接收器。  广播接收器可以自由地对自己感兴趣的广播继续注册，注册广播一般有2种，在代码中注册（动态注册）和在AndroidManifest.xml中注册（静态注册）。  </p>
<h3 id="1-1创建广播接收器"><a href="#1-1创建广播接收器" class="headerlink" title="1.1创建广播接收器"></a>1.1创建广播接收器</h3><p>新建一个类，让它继承自BroadcastReceiver，并重写onReceive()方法就可以。当有广播到来时，onReceive()方法就会得到执行，处理逻辑可以在方法中实现。  </p>
<h4 id="1-1-1动态注册"><a href="#1-1-1动态注册" class="headerlink" title="1.1.1动态注册"></a>1.1.1动态注册</h4><p>通过动态注册的方式编写一个能够监听网络变化的程序：  </p>
<pre><code>//新建BroadcastReceiver项目，修改MainActivity代码
public class MainActivity extends AppCompatActivity {

    private IntentFilter intentFilter;
    private NetworkChangeReceiver networkChangeReceiver;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
           setContentView(R.layout.activity_main);
        intentFilter = new IntentFilter();//创建intentfileter实例
        /*添加action，网络发生变化时，系统发出一条值为android.net.conn.CONNECTIVITY_CHANGE的广播。要监听什么，这里添加相应的action*/
        intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);
        networkChangeReceiver = new NetworkChangeReceiver();//创建实例
        registerReceiver(networkChangeReceiver,intentFilter);//注册
    }

@Override
protected void onDestroy() {
    super.onDestroy();
    unregisterReceiver(networkChangeReceiver);//动态注册的的广播接收器需要取消注册
}

class NetworkChangeReceiver extends BroadcastReceiver{//内部类并继承BroadcastReceiver
    @Override
    public void onReceive(Context context, Intent intent) {//重写onReceive方法
        //getSystemService方法得到ConnectivityManager（管理网络连接的系统服务类）的实例
        ConnectivityManager connectionManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo();
        if(networkInfo!=null &amp;&amp; networkInfo.isAvailable()){
            Toast.makeText(context,&quot;network is available&quot; , Toast.LENGTH_SHORT).show();
        }else {
            Toast.makeText(context,&quot;network is unavailable&quot;,Toast.LENGTH_SHORT).show();
        }
    }
    }
}
</code></pre><p>程序需要进行对用户比较敏感的操作，需要在配置文件(AndroidManifest.xml)中声明权限：  </p>
<pre><code>uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; //添加此行  
</code></pre><h4 id="1-1-2静态注册（实现开机启动）"><a href="#1-1-2静态注册（实现开机启动）" class="headerlink" title="1.1.2静态注册（实现开机启动）"></a>1.1.2静态注册（实现开机启动）</h4><p>动态注册的广播接收器可以自由地控制注册和注销，很灵活，但是必须要在程序启动之后才能接收广播。使用静态注册可以在程序未启动的情况下接收到广播。程序接收一条开机广播，收到后执行onReceive()方法来执行相应的逻辑。<br> 在.broadcasttest包下右击-&gt;New-&gt;Other-&gt;Broadcast Recevier,新建BootCompleteRecevier：  </p>
<pre><code>public class BootCompeleteReceiver extends BroadcastReceiver {

@Override
public void onReceive(Context context, Intent intent) {
    Toast.makeText(context,&quot;Boot Compelete&quot; , Toast.LENGTH_LONG).show();//弹出提示信息
}
}     
</code></pre><p>静态广播接收器要在AndroidManifest.xml中注册才可以使用，Android Studio创建的已经自动注册：  </p>
<pre><code>&lt;application
    ...
    &lt;receiver  //静态广播接收器注册
        android:name=&quot;.BootCompeleteReceiver&quot;
        android:enabled=&quot;true&quot;
        android:exported=&quot;true&quot;&gt;
        &lt;intent-filter&gt;  //添加action
            &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
&lt;/application&gt;
</code></pre><hr>
<pre><code>//在AndroidManifest.xml中添加权限
&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;
</code></pre><h2 id="2、发送自定义广播"><a href="#2、发送自定义广播" class="headerlink" title="2、发送自定义广播"></a>2、发送自定义广播</h2><p>发送广播之前需要定义一个广播接收器来准备接收此广播才行，不然白发。  </p>
<h3 id="2-1发送标准广播"><a href="#2-1发送标准广播" class="headerlink" title="2.1发送标准广播"></a>2.1发送标准广播</h3><p>新建一个MyBroadcastReceiver：  </p>
<pre><code>public class MyBroadcastReceiver extends BroadcastReceiver {

@Override
public void onReceive(Context context, Intent intent) {
    Toast.makeText(context,&quot;received in MyBroadcastReceiver&quot; , Toast.LENGTH_LONG).show();
}
}
</code></pre><hr>
<pre><code>//修改AndroidManifest.xml注册
   &lt;receiver
        android:name=&quot;.MyBroadcastReceiver&quot;
        android:enabled=&quot;true&quot;
        android:exported=&quot;true&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;com.example.xxxxx.broadcasttest.MY_BROADCAST&quot; /&gt;//接收值过滤
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
</code></pre><hr>
<pre><code>//在activity_main.xml中定义按钮用于发送广播的触发点
    &lt;Button
    android:id=&quot;@+id/button&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;send broadcast&quot;/&gt;
</code></pre><hr>
<pre><code>//在MainActivity中修改
    @Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    Button button = (Button)findViewById(R.id.button);
    button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {//按钮点击事件中添加发送自定义广播逻辑
            Intent intent = new  Intent(&quot;com.example.xxxxx.broadcasttest.MY_BROADCAST&quot;);//通过intent传入
            sendBroadcast(intent);
        }
    });
}
</code></pre><h3 id="2-2发送有序广播"><a href="#2-2发送有序广播" class="headerlink" title="2.2发送有序广播"></a>2.2发送有序广播</h3><p>广播是一种可以跨进程的通信方式，我们应用程序内发出的广播，其他应用程序是可以收到的。<br>新建BroadcastTest2项目，项目下新建一个广播接收器：  </p>
<pre><code>public class AnotherBroadcastReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context,&quot;received in AnotherBroadcastReceiver&quot; , Toast.LENGTH_LONG).show();
        }
}
</code></pre><p> 在AndroidManifest.xml中修改这个广播接收器：  </p>
<pre><code> //修改AndroidManifest.xml注册
&lt;receiver
     android:name=&quot;.AnotherBroadcastReceiver&quot; //注册AnotherBroadcastReceiver
     android:enabled=&quot;true&quot;
     android:exported=&quot;true&quot;&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=&quot;com.example.xxxxx.broadcasttest.MY_BROADCAST&quot; /&gt;//同样接收...broadcasttest.MY_BROADCAST这条广播
     &lt;/intent-filter&gt;
 &lt;/receiver&gt;
</code></pre><p>发送有序广播使用sendOrderBroadcast()，修改BroadcastTest项目的MainActivity代码： </p>
<pre><code>//修改BroadcastTest项目下的MainActivity        
...
button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {//按钮点击事件中添加发送自定义广播逻辑
            Intent intent = new  Intent(&quot;com.example.xxxxx.broadcasttest.MY_BROADCAST&quot;);//通过intent传入
            sendOrderBroadcast(intent,null);//发送有序广播，第一个参数intent，第二个参数是权限
        }
    });
...
</code></pre><p>当目前为止，效果上和标准广播没什么区别，但是有序广播是可以有先后顺序和截断的。在BroadcastTest2项目下修改AndroidManifest.xml代码设置优先级：  </p>
<pre><code>&lt;receiver
        android:name=&quot;.AnotherBroadcastReceiver&quot; //注册AnotherBroadcastReceiver
        android:enabled=&quot;true&quot;
        android:exported=&quot;true&quot;&gt;
        &lt;intent-filter  android:priority=&quot;100&quot;&gt;//设置接收MY_BROADCAST的优先级，越高越先收到
            &lt;action android:name=&quot;com.example.xxxxx.broadcasttest.MY_BROADCAST&quot; /&gt;//同样接收...broadcasttest.MY_BROADCAST这条广播
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
</code></pre><p>这样就可以保证在AnotherBroadcastReceiver之前收到广播。<br>如果需要截断，如在MyBroadcastReceiver下调用abortBroadcast()方法将这条广播截断，后面的广播接收器就无法再接收到这条广播。  </p>
<pre><code>public class MyBroadcastReceiver extends BroadcastReceiver {

@Override
public void onReceive(Context context, Intent intent) {
    Toast.makeText(context,&quot;received in MyBroadcastReceiver&quot; , Toast.LENGTH_LONG).show();
    abortBroadcast();//截断广播
}
}
</code></pre><h3 id="2-3使用本地广播"><a href="#2-3使用本地广播" class="headerlink" title="2.3使用本地广播"></a>2.3使用本地广播</h3><p>前面的方式发出的广播可以被其他任何应用程序接收到，如果发送的广播携带有关键数据，可能会造成安全问题。使用本地广播机制可以使发出的广播只能够在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播。<br>本地广播使用一个LocalBroadcastManager来对广播进行管理，并提供了发送广播和接收广播的方法。修改MainActivity中的代码：  </p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private IntentFilter intentFilter;
  private LocalReceiver localReceiver;
  private LocalBroadcastManager   localBroadcastManager;

@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    localBroadcastManager = LocalBroadcastManager.getInstance(this);//获取实例

    Button button = (Button)findViewById(R.id.button);
    button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Intent intent = new Intent(&quot;com.example.xxxxx.broadcasttest.LOCAL_BROADCAST&quot;);
            localBroadcastManager.sendBroadcast(intent);//发送本地广播
        }
    });

    intentFilter = new IntentFilter();
    intentFilter.addAction(&quot;com.example.xxxxx.broadcasttest.LOCAL_BROADCAST&quot;);
    localReceiver = new LocalReceiver();
    localBroadcastManager.registerReceiver(localReceiver,intentFilter);//注册本地广播监听器
}

@Override
protected void onDestroy() {
    super.onDestroy();
    localBroadcastManager.unregisterReceiver(localReceiver);
}

class LocalReceiver extends BroadcastReceiver{
  @Override
  public void onReceive(Context context, Intent intent) {
      Toast.makeText(context,&quot;received local broadcast&quot;,Toast.LENGTH_SHORT).show();
  }
 }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/06/四、广播/" data-id="cjyedanxb001cey6c1fqpvhn0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-三、UI开发工具(控件)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/05/三、UI开发工具(控件)/" class="article-date">
  <time datetime="2018-06-05T03:54:16.000Z" itemprop="datePublished">2018-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/05/三、UI开发工具(控件)/">三、UI开发工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="三、UI开发工具"><a href="#三、UI开发工具" class="headerlink" title="三、UI开发工具"></a>三、UI开发工具</h1><h2 id="1、常用控件的使用方法"><a href="#1、常用控件的使用方法" class="headerlink" title="1、常用控件的使用方法"></a>1、常用控件的使用方法</h2><h3 id="1-1TextView"><a href="#1-1TextView" class="headerlink" title="1.1TextView"></a>1.1TextView</h3><p>主要用于在界面中显示一段文本信息。  </p>
<pre><code>&lt;TextView
    android:id=&quot;@+id/text_view&quot;   //定义控件唯一标识符
    android:layout_width=&quot;match_parent&quot;   //控件宽度，和父布局大小一样
    android:layout_height=&quot;wrap_content&quot;  //控件高度，控件大小刚好包含里面的内容
    android:text=&quot;This is TextView&quot;  /&gt;    //显示的文本内容
</code></pre><p>所有控件都有2个属性，三种值：match_parent、fill_parent、wrap_content。<br>前两个一样，表示布局和父布局的大小一样，推荐match_parent; wrap_content表示当前控件的大小能够刚好包含住里面的内容就行。也可以对高度和宽度指定固定大小，但是这样会出现不同手机屏幕适配方面的问题。<br>指定文字的对齐方式android:gravity  </p>
<pre><code>android:gravity=&quot;center&quot;  //还有top、bottom、left、right，可以用“|”同时指定多个值
</code></pre><p>android:textSize 指定文字大小，android中以sp作为字体大小单位；<br>android:textColor 指定文字颜色  </p>
<h3 id="1-2Button"><a href="#1-2Button" class="headerlink" title="1.2Button"></a>1.2Button</h3><p>程序用于和用户进行交互的重要控件。  </p>
<pre><code>&lt;Button
    android:id=&quot;@+id/button&quot;   //定义控件唯一标识符
    android:layout_width=&quot;match_parent&quot;   //控件宽度，和父布局大小一样
    android:layout_height=&quot;wrap_content&quot;  //控件高度，控件大小刚好包含里面的内容
    android:text=&quot;Button&quot;  /&gt;  //系统对Button中字母进行大写转换
</code></pre><p>android:textAllCaps=”false” 禁用大写转换。<br>在MainActivity中为Button点击事件注册监听器：  </p>
<pre><code>public class MainActivity extends AppCompatActivity{
    @Override
    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button)findViewById(R.id.button);
        button.setOnclickListener(new View.OnClickListener){
            @Override
            public void onClick(View v){
                //此处添加逻辑
            }
        }
    }
}
</code></pre><h3 id="1-3EditText"><a href="#1-3EditText" class="headerlink" title="1.3EditText"></a>1.3EditText</h3><p>用于和用户进行交互的一个重要控件，允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理。  </p>
<pre><code>&lt;EditText
    android:id = &quot;@+id/edit_text&quot;
    android:layout_width = &quot;match_parent&quot;
    android:layout_height = &quot;wrap_content&quot;
/&gt;
</code></pre><p>在输入框中显示一些提示性的文字，用户输入任何内容，提示性文字就会消失：  </p>
<pre><code>android:hint = &quot;Type something here&quot; 
</code></pre><p>输入内容长度限制：  </p>
<pre><code>android:maxLines = &quot;2&quot;  //最大行数为两行,超过2行文本会向上滚动
</code></pre><h3 id="1-4ImageView"><a href="#1-4ImageView" class="headerlink" title="1.4ImageView"></a>1.4ImageView</h3><p>用于在界面展示图片，图片通常放在以drawable开头的目录下。<br>指定一张图片android:src  </p>
<pre><code>&lt;ImageView
    ...
    android:src=&quot;@drawable/img_1&quot; /&gt;
</code></pre><p>代码中动态修改ImageView中的图片：  </p>
<pre><code>package com.example.xxxxx.uiwidgettest;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageView;

public class MainActivity extends AppCompatActivity implements View.OnClickListener{
private ImageView imageView;
   private EditText editText;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    Button button = (Button)findViewById(R.id.button);
    editText = (EditText)findViewById(R.id.edit_text);
    imageView = (ImageView)findViewById(R.id.image_view);
    button.setOnClickListener(this);
}

@Override
public void onClick(View v) {
    switch (v.getId()){
        case R.id.button:
            imageView.setImageResource(R.drawable.img_2);//将图片改为img_2
    }
    }
}
</code></pre><h3 id="1-5ProgressBar"><a href="#1-5ProgressBar" class="headerlink" title="1.5ProgressBar"></a>1.5ProgressBar</h3><p>用于在界面上显示一个进度条，表示程序正在加载一些数据。  </p>
<pre><code>&lt;ProgressBar
  android:id=&quot;@+id/progress_bar&quot;
  android:layout_width=&quot;match_parent&quot;
  android:layout_height=&quot;wrap_content&quot; /&gt;
</code></pre><p>Android控件的可见属性，通过android:visibility进行指定，三种值：visible、invisible、gone<br>visible：可见的，默认值<br>invisible：不可见，任然占据原来的位置和大小，相当于透明<br>gone：不可见也不占用屏幕空间<br>通过代码设置控件的可见性，setVisibility()方法，传入View.VISIBLE、View.INVISIBLE、View.GONE<br>判断ProgressBar的可见性：  </p>
<pre><code>progressBar.getVisibility() == View.GONE//判断是否是GONE
progressBar.setVisibility(View.VISIBLE);//修改可见性为可见
</code></pre><p>指定ProgressBar不同的样式，通过style属性可以将它指定成水平进度条：  </p>
<pre><code>&lt;ProgressBar
   android:id=&quot;@+id/progress_bar&quot;
   android:layout_width=&quot;match_parent&quot;
   android:layout_height=&quot;wrap_content&quot; 
   style=&quot;?android:attr/progressBarStyleHorizontal&quot;//设置为水平进度条
   android:max=&quot;100&quot;/&gt;   //进度条最大值为100
</code></pre><h3 id="1-6AlertDialog"><a href="#1-6AlertDialog" class="headerlink" title="1.6AlertDialog"></a>1.6AlertDialog</h3><p>在当前界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力。一般用于提示一些非常重要的内容或者警告信息。  </p>
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{
    private ImageView imageView;
    private EditText editText;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Button button = (Button)findViewById(R.id.button);
        editText = (EditText)findViewById(R.id.edit_text);
        imageView = (ImageView)findViewById(R.id.image_view);
        button.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.button:
            AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);//创建AlertDialog实例
            dialog.setTitle(&quot;this is dialog&quot;);//设置对话框标题
            dialog.setMessage(&quot;something important&quot;);//设置内容
            dialog.setCancelable(false);//是否可取消
            dialog.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() {//设置确定按钮的点击事件
                @Override
                public void onClick(DialogInterface dialog, int which) {

                }
            });
            dialog.setNegativeButton(&quot;Cancle&quot;, new DialogInterface.OnClickListener() {//设置取消按钮的点击事件
                @Override
                public void onClick(DialogInterface dialog, int which) {

                }
            });
            dialog.show();//调用show方法将对话框显示出来
            break;
        default:
            break;
    }
}
</code></pre><p>}</p>
<h3 id="1-7ProgressDialog"><a href="#1-7ProgressDialog" class="headerlink" title="1.7ProgressDialog"></a>1.7ProgressDialog</h3><p>和AlertDialog类似，不过ProgressDialog会在对话框中显示一个进度条，一般用于标识操作比较耗时，让用户等待。  </p>
<pre><code>@Override
public void onClick(View v) {
    switch (v.getId()){
        case R.id.button:
            ProgressDialog processDialog = new ProgressDialog(MainActivity.this);
            processDialog.setTitle(&quot;This is ProgressDialog&quot;);
            processDialog.setMessage(&quot;Loading...&quot;);
            processDialog.setCancelable(true);
            processDialog.show();
            break;
        default:
            break;
    }
}
</code></pre><p>如果setCancelable中传入false，则不能通过back键取消掉，那么在代码中需要加载完成后必须调用ProgressDialog的dimiss()方法关闭对话框，否则会一直存在。</p>
<h2 id="2、四种基本布局"><a href="#2、四种基本布局" class="headerlink" title="2、四种基本布局"></a>2、四种基本布局</h2><p>布局是一种可以放置很多空间的容器，可以按照一定的规律调整内部空间的位置。布局的内部出了放置控件外，也可以放置布局，通过多层布局的嵌套。  </p>
<h3 id="2-1线性布局"><a href="#2-1线性布局" class="headerlink" title="2.1线性布局"></a>2.1线性布局</h3><p>排列方向：  </p>
<pre><code>android:orientation=&quot;vertical&quot;  //垂直排列
android:orientation=&quot;horizontal&quot;  //水平排列

android:layout_gravity =  &quot;top&quot;//控件在布局中的对齐方式
</code></pre><p>线性布局中可以用比例的方式指定控件的大小android:layout_weight，设置了这个属性控件的宽度就不应该在由android:layout_width来决定。LinearLayout下所有控件指定的layout_weight相加，得到一个总值，该控件的layout_weight值除以总值就是占屏幕的宽度的大小。</p>
<h3 id="2-2相对布局"><a href="#2-2相对布局" class="headerlink" title="2.2相对布局"></a>2.2相对布局</h3><p>RelativeLayout是非常常用的布局，和LinearLayout排列规则不同，RelativeLayout更加随意，可以通过相对定位的方式让控件出现在布局的任何位置。  </p>
<pre><code>&lt;RelativeLayout  ...
    ...
    &lt;Button
        android:id=&quot;@+id/button3&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_centerInparent=&quot;true&quot;
        android:text=&quot;Button3&quot; /&gt;
      &lt;Button
        android:id=&quot;@+id/button2&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_above=&quot;@id/button3&quot; //在button3的上方
        android:layout_toLeftOf=&quot;@id/button3&quot;  //在button3的左边
        android:text=&quot;Button2&quot; /&gt;
    ...
&lt;/RelativeLayout&gt;
</code></pre><p>一个控件去引用另外一个控件的id时，该控件一定要定义在引用控件的后面，不然会出现找不到id的情况。  </p>
<h3 id="2-3帧布局"><a href="#2-3帧布局" class="headerlink" title="2.3帧布局"></a>2.3帧布局</h3><p>FrameLayout应用场景较少，所有的控件都默认摆放在布局的左上角。<br>也可以使用android:layout_gravity来指定对齐方式。  </p>
<h3 id="2-4百分比布局"><a href="#2-4百分比布局" class="headerlink" title="2.4百分比布局"></a>2.4百分比布局</h3><p>之前的布局只要LineLayout支持使用layout_weight属性来实现比例指定控件大小的功能。引入百分比布局来解决，这种布局中不再使用wrap_content、match_parent等方式指定控件大小，而是直接指定控件在布局中所占的百分比，这样可以轻松实现任意比例分割布局。<br>百分比布局只为FrameLayout和RelativeLayout进行功能扩展，提供了PercentFrameLayout和PercentRelativeLayout这两个全新布局。<br>在项目的build.gradle中添加百分比布局库的依赖就能保证百分比布局在Android所有系统版本上兼容。 </p>
<pre><code>&lt;android.support.percent.PercentFrameLayout
    ...
    &lt;Button
        ...
        app:layout_widthPercent=&quot;50%&quot;
        app:layout_heightPercent=&quot;50%&quot; /&gt;
    ...

&lt;/android.support.percent.PercentFrameLayout&gt;
</code></pre><h2 id="3、创建自定义控件"><a href="#3、创建自定义控件" class="headerlink" title="3、创建自定义控件"></a>3、创建自定义控件</h2><p>所有控件都是直接或间接继承自View，所有布局都是直接或间接继承自ViewGroup。View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，我们使用的控件就是在View的基础之上又添加各自特有的功能。  </p>
<h3 id="3-1引入布局创建控件"><a href="#3-1引入布局创建控件" class="headerlink" title="3.1引入布局创建控件"></a>3.1引入布局创建控件</h3><p>新建一个title.xml文件  </p>
<pre><code>  &lt;LinearLayout ...
    ...
    &lt;Button
        .. /&gt;
    &lt;TextView
        ... /&gt;
    ...
&lt;/LinearLayout&gt;

//部分属性说明
android:background = &quot;@drawable/edit_png&quot;//为布局或控件指定背景，可以使用颜色或图片填充
android:layout_margin = &quot;5dp&quot;//指定控件在各个方向上偏移的距离
android:layout_marginLeft或者android:layout_marginTop
</code></pre><p>在程序中使用，在activity_main.xml中添加：  </p>
<pre><code>&lt;LinearLayout ...
    ...
    &lt;include layout=&quot;@layout/title&quot;/&gt;  //include语句引入
&lt;/LinearLayout&gt;
</code></pre><h3 id="3-2创建自定义控件"><a href="#3-2创建自定义控件" class="headerlink" title="3.2创建自定义控件"></a>3.2创建自定义控件</h3><p>新建TitleLayout继承自LinearLayout，让它成为自定义的标题栏控件：  </p>
<pre><code>pulic class TitleLayout extends LinearLayout{
    public TitleLayout(Context context , AttributeSet attrs){//布局中引入TitleLayout控件就会调用这个构造函数
        super(context,attrs);
        //借助LayoutInflater实现标题栏布局多态加载，from方法构建一个LayoutInflater对象
        LayoutInflater.from(context).inflate(R.layout.title,this);//inflate方法可以多态加载一个布局文件。
        //inflate第一个参数是加载的布局文件的id，第二个参数是给加载好的布局在添加一个父布局
    }
}
</code></pre><p>创建好布局文件后，在布局文件中添加自定义控件，修改activity_main.xml中的代码：  </p>
<pre><code>&lt;LinearLayout ...
    ...
    &lt;com.example.uicustomviews.TitleLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot; /&gt;
</code></pre><p>给标题栏的按钮注册点击事件，修改TitleLayout代码：  </p>
<pre><code>pulic class TitleLayout extends LinearLayout{
    public TitleLayout(Context context , AttributeSet attrs){
        super(context,attrs);
        LayoutInflater.from(context).inflate(R.layout.title,this);
        Button titleBack =(Button)findViewByid(R.id.title_back);
        Button titleBack =(Button)findViewByid(R.ID.title_edit);
        titleBack.setOnClickListener(new OnClickListener){
            @Override
            public void onClick(View v){
                ((Activity)getContext()).finish();
            }
        };
        titleEdit.setOnClickListener(new OnClickListener){
            @Override
            public void onClick(View v){
                Toast.makeText(getContext(),&quot;You Clicked Edit button&quot;,Toast.LENGTH_SHORT).show();
            }
        };
    }
}
</code></pre><h2 id="4、滚动控件-ReyclerView-134页，未完成"><a href="#4、滚动控件-ReyclerView-134页，未完成" class="headerlink" title="4、滚动控件-ReyclerView(134页，未完成)"></a>4、滚动控件-ReyclerView(134页，未完成)</h2><p>ReyclerView也属于新增的控件，为了让RecyclerView在所有Android版本上都能使用，将其定义在support库中。在app/build.gradle文件中添加：  </p>
<pre><code>dependencies {
implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
implementation &apos;com.android.support:appcompat-v7:27.1.1&apos;
implementation &apos;com.android.support.constraint:constraint-layout:1.1.0&apos;
testImplementation &apos;junit:junit:4.12&apos;
androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos;
androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;
implementation &apos;com.android.support:recyclerview-v7:27.1.1&apos;  //添加内容
</code></pre><p>}<br>点击Sync Now进行同步。 修改activity_main.xml中的代码：  </p>
<pre><code>&lt;android.support.v7.widget.RecyclerView  //添加RecyclerView控件
    android:id=&quot;@+id/recycler_view&quot;
        android:layout_height=&quot;match_parent&quot;
    android:layout_width=&quot;match_parent&quot; /&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/05/三、UI开发工具(控件)/" data-id="cjyedanxa001bey6ceb4b0zzw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/使用指南/">使用指南</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/问题总结/">问题总结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 16.67px;">Android</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/使用指南/" style="font-size: 13.33px;">使用指南</a> <a href="/tags/问题总结/" style="font-size: 10px;">问题总结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/18/Android消息机制之handler原理/">Android消息机制之handler原理</a>
          </li>
        
          <li>
            <a href="/2019/07/04/网上资料链接/">网上资料链接</a>
          </li>
        
          <li>
            <a href="/2019/06/28/inflate导致的空指针/">inflate导致的空指针</a>
          </li>
        
          <li>
            <a href="/2018/12/07/hexo使用指南/">hexo使用指南</a>
          </li>
        
          <li>
            <a href="/2018/12/07/hello-world/">hexo基本操作</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>