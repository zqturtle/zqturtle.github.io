<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-五、内容提供器(Content Provider)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/07/五、内容提供器(Content Provider)/" class="article-date">
  <time datetime="2018-06-07T13:41:00.000Z" itemprop="datePublished">2018-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/07/五、内容提供器(Content Provider)/">五、内容提供器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="五、内容提供器"><a href="#五、内容提供器" class="headerlink" title="五、内容提供器"></a>五、内容提供器</h1><p>内容提供器(Content Provider)主要用于在不同的应用程序之间实现数据的共享功能，它提供了一套完整的机制，允许一个程序访问另外一个程序中的数据，同时还能有效保证被访问数据的安全性。是Android实现跨程序共享数据的标准方式。    </p>
<h2 id="1、运行时权限"><a href="#1、运行时权限" class="headerlink" title="1、运行时权限"></a>1、运行时权限</h2><h3 id="1-1Android权限机制详解"><a href="#1-1Android权限机制详解" class="headerlink" title="1.1Android权限机制详解"></a>1.1Android权限机制详解</h3><p>访问系统的网络状态以及监听开机广播，在AndroidManifest.xml中添加权限声明：  </p>
<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.example.xxxxx.broadcasttest&quot;&gt;

&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;  //访问网络状态权限声明
   &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;  //监听开机广播权限声明
&lt;/manifest&gt;
</code></pre><p>访问系统的网络状态和监听开机广播涉及到用户设备的安全性，因此必须在AndroidManifest.xml中加入权限声明，否则程序会崩溃。<br>常用软件普遍存在滥用权限的情况，不管到底用不用得到先把权限申请了再说。所有Android开发团队从6.0系统加入了运行时权限功能。<br>Android现在的所有权限分为两类，普通权限和危险权限。普通权限是安心不会直接威胁到用户的安全和隐私的权限，系统会帮我们进行授权，不需要用户操作。危险权限则表示哪些可能会触及用户隐私或对社保安全性造成影响的权限，如获取设备联系人、定位设备的地理位置等，这些需要用户手动点击授权，否则程序无法使用相应的功能。  </p>
<table>
<thead>
<tr>
<th style="text-align:left">权限组名</th>
<th style="text-align:center">权限名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CALENDAR</td>
<td style="text-align:center">READ_CALENDAR</td>
</tr>
<tr>
<td style="text-align:left">CALENDAR</td>
<td style="text-align:center">WRITE_CALENDAR</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">CAMERA</td>
<td style="text-align:center">CAMERA</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">CONTACTS</td>
<td style="text-align:center">READ_CONTACTS</td>
</tr>
<tr>
<td style="text-align:left">CONTACTS</td>
<td style="text-align:center">WRITE_CONTACTS</td>
</tr>
<tr>
<td style="text-align:left">CONTACTS</td>
<td style="text-align:center">GET_CONTACTS</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">LOCATION</td>
<td style="text-align:center">ACCESS_FINE_LOCATION</td>
</tr>
<tr>
<td style="text-align:left">LOCATION</td>
<td style="text-align:center">ACCESS_COARSE_LOCATION</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">MICROPHONE</td>
<td style="text-align:center">RECORD_AUDIO</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">READ_PHONE_STATE</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">CALL_PHONE</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">READ_CALL_LOG</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">WRITE_CALL_STATE</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">ADD_VOICEMAIL</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">USE_SIP</td>
</tr>
<tr>
<td style="text-align:left">PHONE</td>
<td style="text-align:center">PROCESS_OUTGOING_CALLS</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">SENSORS</td>
<td style="text-align:center">BODY_SENSORS</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">SMS</td>
<td style="text-align:center">SEND_SMS</td>
</tr>
<tr>
<td style="text-align:left">SMS</td>
<td style="text-align:center">RECEIVE_SMS</td>
</tr>
<tr>
<td style="text-align:left">SMS</td>
<td style="text-align:center">READ_SMS</td>
</tr>
<tr>
<td style="text-align:left">SMS</td>
<td style="text-align:center">RECEIVE_WAP_SMS</td>
</tr>
<tr>
<td style="text-align:left">SMS</td>
<td style="text-align:center">RECEIVE_MMS</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
<tr>
<td style="text-align:left">STORAGE</td>
<td style="text-align:center">READ_EXTERNAL_STORAGE</td>
</tr>
<tr>
<td style="text-align:left">STORAGE</td>
<td style="text-align:center">WRITE_EXTERNAL_STORAGE</td>
</tr>
<tr>
<td style="text-align:left">—————————</td>
<td style="text-align:center">————————————-</td>
</tr>
</tbody>
</table>
<p>使用权限时，如果属于这张表的权限，就需要进行运行时权限处理，如果不在这样表中那么只需要在AndroidManifest.xml文件中添加一下权限声明就可以。<br>权限处理时处理的是权限名，但是用户授权后对应的权限组中其他的权限也会同时被授权。  </p>
<h3 id="1-2运行时权限申请（262页）"><a href="#1-2运行时权限申请（262页）" class="headerlink" title="1.2运行时权限申请（262页）"></a>1.2运行时权限申请（262页）</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/07/五、内容提供器(Content Provider)/" data-id="ck2n3djm6000uxd6cv2sq7ak1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-四、广播" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/06/四、广播/" class="article-date">
  <time datetime="2018-06-06T03:11:06.000Z" itemprop="datePublished">2018-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/06/四、广播/">四、广播</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="四、广播"><a href="#四、广播" class="headerlink" title="四、广播"></a>四、广播</h1><p>Android中广播的两种类型：标准广播和有序广播<br><strong>标准广播：</strong>异步执行的广播，广播发出后广播接收器几乎同时接收者条广播信息，没有先后顺序。这种广播效率高，但是无法被截断。<br><strong>有序广播：</strong>同步执行的广播，广播发出后同一时刻只会有一个广播接收器接收到这条广播消息，逻辑执行完毕后广播才继续传递。前面的广播接收器可以截断正在传递的广播。  </p>
<h2 id="1、接收系统广播"><a href="#1、接收系统广播" class="headerlink" title="1、接收系统广播"></a>1、接收系统广播</h2><p>要接收广播就需要使用广播接收器。  广播接收器可以自由地对自己感兴趣的广播继续注册，注册广播一般有2种，在代码中注册（动态注册）和在AndroidManifest.xml中注册（静态注册）。  </p>
<h3 id="1-1创建广播接收器"><a href="#1-1创建广播接收器" class="headerlink" title="1.1创建广播接收器"></a>1.1创建广播接收器</h3><p>新建一个类，让它继承自BroadcastReceiver，并重写onReceive()方法就可以。当有广播到来时，onReceive()方法就会得到执行，处理逻辑可以在方法中实现。  </p>
<h4 id="1-1-1动态注册"><a href="#1-1-1动态注册" class="headerlink" title="1.1.1动态注册"></a>1.1.1动态注册</h4><p>通过动态注册的方式编写一个能够监听网络变化的程序：  </p>
<pre><code>//新建BroadcastReceiver项目，修改MainActivity代码
public class MainActivity extends AppCompatActivity {

    private IntentFilter intentFilter;
    private NetworkChangeReceiver networkChangeReceiver;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
           setContentView(R.layout.activity_main);
        intentFilter = new IntentFilter();//创建intentfileter实例
        /*添加action，网络发生变化时，系统发出一条值为android.net.conn.CONNECTIVITY_CHANGE的广播。要监听什么，这里添加相应的action*/
        intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);
        networkChangeReceiver = new NetworkChangeReceiver();//创建实例
        registerReceiver(networkChangeReceiver,intentFilter);//注册
    }

@Override
protected void onDestroy() {
    super.onDestroy();
    unregisterReceiver(networkChangeReceiver);//动态注册的的广播接收器需要取消注册
}

class NetworkChangeReceiver extends BroadcastReceiver{//内部类并继承BroadcastReceiver
    @Override
    public void onReceive(Context context, Intent intent) {//重写onReceive方法
        //getSystemService方法得到ConnectivityManager（管理网络连接的系统服务类）的实例
        ConnectivityManager connectionManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo();
        if(networkInfo!=null &amp;&amp; networkInfo.isAvailable()){
            Toast.makeText(context,&quot;network is available&quot; , Toast.LENGTH_SHORT).show();
        }else {
            Toast.makeText(context,&quot;network is unavailable&quot;,Toast.LENGTH_SHORT).show();
        }
    }
    }
}
</code></pre><p>程序需要进行对用户比较敏感的操作，需要在配置文件(AndroidManifest.xml)中声明权限：  </p>
<pre><code>uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; //添加此行  
</code></pre><h4 id="1-1-2静态注册（实现开机启动）"><a href="#1-1-2静态注册（实现开机启动）" class="headerlink" title="1.1.2静态注册（实现开机启动）"></a>1.1.2静态注册（实现开机启动）</h4><p>动态注册的广播接收器可以自由地控制注册和注销，很灵活，但是必须要在程序启动之后才能接收广播。使用静态注册可以在程序未启动的情况下接收到广播。程序接收一条开机广播，收到后执行onReceive()方法来执行相应的逻辑。<br> 在.broadcasttest包下右击-&gt;New-&gt;Other-&gt;Broadcast Recevier,新建BootCompleteRecevier：  </p>
<pre><code>public class BootCompeleteReceiver extends BroadcastReceiver {

@Override
public void onReceive(Context context, Intent intent) {
    Toast.makeText(context,&quot;Boot Compelete&quot; , Toast.LENGTH_LONG).show();//弹出提示信息
}
}     
</code></pre><p>静态广播接收器要在AndroidManifest.xml中注册才可以使用，Android Studio创建的已经自动注册：  </p>
<pre><code>&lt;application
    ...
    &lt;receiver  //静态广播接收器注册
        android:name=&quot;.BootCompeleteReceiver&quot;
        android:enabled=&quot;true&quot;
        android:exported=&quot;true&quot;&gt;
        &lt;intent-filter&gt;  //添加action
            &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
&lt;/application&gt;
</code></pre><hr>
<pre><code>//在AndroidManifest.xml中添加权限
&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;
</code></pre><h2 id="2、发送自定义广播"><a href="#2、发送自定义广播" class="headerlink" title="2、发送自定义广播"></a>2、发送自定义广播</h2><p>发送广播之前需要定义一个广播接收器来准备接收此广播才行，不然白发。  </p>
<h3 id="2-1发送标准广播"><a href="#2-1发送标准广播" class="headerlink" title="2.1发送标准广播"></a>2.1发送标准广播</h3><p>新建一个MyBroadcastReceiver：  </p>
<pre><code>public class MyBroadcastReceiver extends BroadcastReceiver {

@Override
public void onReceive(Context context, Intent intent) {
    Toast.makeText(context,&quot;received in MyBroadcastReceiver&quot; , Toast.LENGTH_LONG).show();
}
}
</code></pre><hr>
<pre><code>//修改AndroidManifest.xml注册
   &lt;receiver
        android:name=&quot;.MyBroadcastReceiver&quot;
        android:enabled=&quot;true&quot;
        android:exported=&quot;true&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;com.example.xxxxx.broadcasttest.MY_BROADCAST&quot; /&gt;//接收值过滤
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
</code></pre><hr>
<pre><code>//在activity_main.xml中定义按钮用于发送广播的触发点
    &lt;Button
    android:id=&quot;@+id/button&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;send broadcast&quot;/&gt;
</code></pre><hr>
<pre><code>//在MainActivity中修改
    @Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    Button button = (Button)findViewById(R.id.button);
    button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {//按钮点击事件中添加发送自定义广播逻辑
            Intent intent = new  Intent(&quot;com.example.xxxxx.broadcasttest.MY_BROADCAST&quot;);//通过intent传入
            sendBroadcast(intent);
        }
    });
}
</code></pre><h3 id="2-2发送有序广播"><a href="#2-2发送有序广播" class="headerlink" title="2.2发送有序广播"></a>2.2发送有序广播</h3><p>广播是一种可以跨进程的通信方式，我们应用程序内发出的广播，其他应用程序是可以收到的。<br>新建BroadcastTest2项目，项目下新建一个广播接收器：  </p>
<pre><code>public class AnotherBroadcastReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context,&quot;received in AnotherBroadcastReceiver&quot; , Toast.LENGTH_LONG).show();
        }
}
</code></pre><p> 在AndroidManifest.xml中修改这个广播接收器：  </p>
<pre><code> //修改AndroidManifest.xml注册
&lt;receiver
     android:name=&quot;.AnotherBroadcastReceiver&quot; //注册AnotherBroadcastReceiver
     android:enabled=&quot;true&quot;
     android:exported=&quot;true&quot;&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=&quot;com.example.xxxxx.broadcasttest.MY_BROADCAST&quot; /&gt;//同样接收...broadcasttest.MY_BROADCAST这条广播
     &lt;/intent-filter&gt;
 &lt;/receiver&gt;
</code></pre><p>发送有序广播使用sendOrderBroadcast()，修改BroadcastTest项目的MainActivity代码： </p>
<pre><code>//修改BroadcastTest项目下的MainActivity        
...
button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {//按钮点击事件中添加发送自定义广播逻辑
            Intent intent = new  Intent(&quot;com.example.xxxxx.broadcasttest.MY_BROADCAST&quot;);//通过intent传入
            sendOrderBroadcast(intent,null);//发送有序广播，第一个参数intent，第二个参数是权限
        }
    });
...
</code></pre><p>当目前为止，效果上和标准广播没什么区别，但是有序广播是可以有先后顺序和截断的。在BroadcastTest2项目下修改AndroidManifest.xml代码设置优先级：  </p>
<pre><code>&lt;receiver
        android:name=&quot;.AnotherBroadcastReceiver&quot; //注册AnotherBroadcastReceiver
        android:enabled=&quot;true&quot;
        android:exported=&quot;true&quot;&gt;
        &lt;intent-filter  android:priority=&quot;100&quot;&gt;//设置接收MY_BROADCAST的优先级，越高越先收到
            &lt;action android:name=&quot;com.example.xxxxx.broadcasttest.MY_BROADCAST&quot; /&gt;//同样接收...broadcasttest.MY_BROADCAST这条广播
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
</code></pre><p>这样就可以保证在AnotherBroadcastReceiver之前收到广播。<br>如果需要截断，如在MyBroadcastReceiver下调用abortBroadcast()方法将这条广播截断，后面的广播接收器就无法再接收到这条广播。  </p>
<pre><code>public class MyBroadcastReceiver extends BroadcastReceiver {

@Override
public void onReceive(Context context, Intent intent) {
    Toast.makeText(context,&quot;received in MyBroadcastReceiver&quot; , Toast.LENGTH_LONG).show();
    abortBroadcast();//截断广播
}
}
</code></pre><h3 id="2-3使用本地广播"><a href="#2-3使用本地广播" class="headerlink" title="2.3使用本地广播"></a>2.3使用本地广播</h3><p>前面的方式发出的广播可以被其他任何应用程序接收到，如果发送的广播携带有关键数据，可能会造成安全问题。使用本地广播机制可以使发出的广播只能够在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播。<br>本地广播使用一个LocalBroadcastManager来对广播进行管理，并提供了发送广播和接收广播的方法。修改MainActivity中的代码：  </p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private IntentFilter intentFilter;
  private LocalReceiver localReceiver;
  private LocalBroadcastManager   localBroadcastManager;

@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    localBroadcastManager = LocalBroadcastManager.getInstance(this);//获取实例

    Button button = (Button)findViewById(R.id.button);
    button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Intent intent = new Intent(&quot;com.example.xxxxx.broadcasttest.LOCAL_BROADCAST&quot;);
            localBroadcastManager.sendBroadcast(intent);//发送本地广播
        }
    });

    intentFilter = new IntentFilter();
    intentFilter.addAction(&quot;com.example.xxxxx.broadcasttest.LOCAL_BROADCAST&quot;);
    localReceiver = new LocalReceiver();
    localBroadcastManager.registerReceiver(localReceiver,intentFilter);//注册本地广播监听器
}

@Override
protected void onDestroy() {
    super.onDestroy();
    localBroadcastManager.unregisterReceiver(localReceiver);
}

class LocalReceiver extends BroadcastReceiver{
  @Override
  public void onReceive(Context context, Intent intent) {
      Toast.makeText(context,&quot;received local broadcast&quot;,Toast.LENGTH_SHORT).show();
  }
 }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/06/四、广播/" data-id="ck2n3djmq001kxd6cqda8f40a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-三、UI开发工具(控件)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/05/三、UI开发工具(控件)/" class="article-date">
  <time datetime="2018-06-05T03:54:16.000Z" itemprop="datePublished">2018-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/05/三、UI开发工具(控件)/">三、UI开发工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="三、UI开发工具"><a href="#三、UI开发工具" class="headerlink" title="三、UI开发工具"></a>三、UI开发工具</h1><h2 id="1、常用控件的使用方法"><a href="#1、常用控件的使用方法" class="headerlink" title="1、常用控件的使用方法"></a>1、常用控件的使用方法</h2><h3 id="1-1TextView"><a href="#1-1TextView" class="headerlink" title="1.1TextView"></a>1.1TextView</h3><p>主要用于在界面中显示一段文本信息。  </p>
<pre><code>&lt;TextView
    android:id=&quot;@+id/text_view&quot;   //定义控件唯一标识符
    android:layout_width=&quot;match_parent&quot;   //控件宽度，和父布局大小一样
    android:layout_height=&quot;wrap_content&quot;  //控件高度，控件大小刚好包含里面的内容
    android:text=&quot;This is TextView&quot;  /&gt;    //显示的文本内容
</code></pre><p>所有控件都有2个属性，三种值：match_parent、fill_parent、wrap_content。<br>前两个一样，表示布局和父布局的大小一样，推荐match_parent; wrap_content表示当前控件的大小能够刚好包含住里面的内容就行。也可以对高度和宽度指定固定大小，但是这样会出现不同手机屏幕适配方面的问题。<br>指定文字的对齐方式android:gravity  </p>
<pre><code>android:gravity=&quot;center&quot;  //还有top、bottom、left、right，可以用“|”同时指定多个值
</code></pre><p>android:textSize 指定文字大小，android中以sp作为字体大小单位；<br>android:textColor 指定文字颜色  </p>
<h3 id="1-2Button"><a href="#1-2Button" class="headerlink" title="1.2Button"></a>1.2Button</h3><p>程序用于和用户进行交互的重要控件。  </p>
<pre><code>&lt;Button
    android:id=&quot;@+id/button&quot;   //定义控件唯一标识符
    android:layout_width=&quot;match_parent&quot;   //控件宽度，和父布局大小一样
    android:layout_height=&quot;wrap_content&quot;  //控件高度，控件大小刚好包含里面的内容
    android:text=&quot;Button&quot;  /&gt;  //系统对Button中字母进行大写转换
</code></pre><p>android:textAllCaps=”false” 禁用大写转换。<br>在MainActivity中为Button点击事件注册监听器：  </p>
<pre><code>public class MainActivity extends AppCompatActivity{
    @Override
    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button)findViewById(R.id.button);
        button.setOnclickListener(new View.OnClickListener){
            @Override
            public void onClick(View v){
                //此处添加逻辑
            }
        }
    }
}
</code></pre><h3 id="1-3EditText"><a href="#1-3EditText" class="headerlink" title="1.3EditText"></a>1.3EditText</h3><p>用于和用户进行交互的一个重要控件，允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理。  </p>
<pre><code>&lt;EditText
    android:id = &quot;@+id/edit_text&quot;
    android:layout_width = &quot;match_parent&quot;
    android:layout_height = &quot;wrap_content&quot;
/&gt;
</code></pre><p>在输入框中显示一些提示性的文字，用户输入任何内容，提示性文字就会消失：  </p>
<pre><code>android:hint = &quot;Type something here&quot; 
</code></pre><p>输入内容长度限制：  </p>
<pre><code>android:maxLines = &quot;2&quot;  //最大行数为两行,超过2行文本会向上滚动
</code></pre><h3 id="1-4ImageView"><a href="#1-4ImageView" class="headerlink" title="1.4ImageView"></a>1.4ImageView</h3><p>用于在界面展示图片，图片通常放在以drawable开头的目录下。<br>指定一张图片android:src  </p>
<pre><code>&lt;ImageView
    ...
    android:src=&quot;@drawable/img_1&quot; /&gt;
</code></pre><p>代码中动态修改ImageView中的图片：  </p>
<pre><code>package com.example.xxxxx.uiwidgettest;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageView;

public class MainActivity extends AppCompatActivity implements View.OnClickListener{
private ImageView imageView;
   private EditText editText;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    Button button = (Button)findViewById(R.id.button);
    editText = (EditText)findViewById(R.id.edit_text);
    imageView = (ImageView)findViewById(R.id.image_view);
    button.setOnClickListener(this);
}

@Override
public void onClick(View v) {
    switch (v.getId()){
        case R.id.button:
            imageView.setImageResource(R.drawable.img_2);//将图片改为img_2
    }
    }
}
</code></pre><h3 id="1-5ProgressBar"><a href="#1-5ProgressBar" class="headerlink" title="1.5ProgressBar"></a>1.5ProgressBar</h3><p>用于在界面上显示一个进度条，表示程序正在加载一些数据。  </p>
<pre><code>&lt;ProgressBar
  android:id=&quot;@+id/progress_bar&quot;
  android:layout_width=&quot;match_parent&quot;
  android:layout_height=&quot;wrap_content&quot; /&gt;
</code></pre><p>Android控件的可见属性，通过android:visibility进行指定，三种值：visible、invisible、gone<br>visible：可见的，默认值<br>invisible：不可见，任然占据原来的位置和大小，相当于透明<br>gone：不可见也不占用屏幕空间<br>通过代码设置控件的可见性，setVisibility()方法，传入View.VISIBLE、View.INVISIBLE、View.GONE<br>判断ProgressBar的可见性：  </p>
<pre><code>progressBar.getVisibility() == View.GONE//判断是否是GONE
progressBar.setVisibility(View.VISIBLE);//修改可见性为可见
</code></pre><p>指定ProgressBar不同的样式，通过style属性可以将它指定成水平进度条：  </p>
<pre><code>&lt;ProgressBar
   android:id=&quot;@+id/progress_bar&quot;
   android:layout_width=&quot;match_parent&quot;
   android:layout_height=&quot;wrap_content&quot; 
   style=&quot;?android:attr/progressBarStyleHorizontal&quot;//设置为水平进度条
   android:max=&quot;100&quot;/&gt;   //进度条最大值为100
</code></pre><h3 id="1-6AlertDialog"><a href="#1-6AlertDialog" class="headerlink" title="1.6AlertDialog"></a>1.6AlertDialog</h3><p>在当前界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力。一般用于提示一些非常重要的内容或者警告信息。  </p>
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{
    private ImageView imageView;
    private EditText editText;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Button button = (Button)findViewById(R.id.button);
        editText = (EditText)findViewById(R.id.edit_text);
        imageView = (ImageView)findViewById(R.id.image_view);
        button.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.button:
            AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);//创建AlertDialog实例
            dialog.setTitle(&quot;this is dialog&quot;);//设置对话框标题
            dialog.setMessage(&quot;something important&quot;);//设置内容
            dialog.setCancelable(false);//是否可取消
            dialog.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() {//设置确定按钮的点击事件
                @Override
                public void onClick(DialogInterface dialog, int which) {

                }
            });
            dialog.setNegativeButton(&quot;Cancle&quot;, new DialogInterface.OnClickListener() {//设置取消按钮的点击事件
                @Override
                public void onClick(DialogInterface dialog, int which) {

                }
            });
            dialog.show();//调用show方法将对话框显示出来
            break;
        default:
            break;
    }
}
</code></pre><p>}</p>
<h3 id="1-7ProgressDialog"><a href="#1-7ProgressDialog" class="headerlink" title="1.7ProgressDialog"></a>1.7ProgressDialog</h3><p>和AlertDialog类似，不过ProgressDialog会在对话框中显示一个进度条，一般用于标识操作比较耗时，让用户等待。  </p>
<pre><code>@Override
public void onClick(View v) {
    switch (v.getId()){
        case R.id.button:
            ProgressDialog processDialog = new ProgressDialog(MainActivity.this);
            processDialog.setTitle(&quot;This is ProgressDialog&quot;);
            processDialog.setMessage(&quot;Loading...&quot;);
            processDialog.setCancelable(true);
            processDialog.show();
            break;
        default:
            break;
    }
}
</code></pre><p>如果setCancelable中传入false，则不能通过back键取消掉，那么在代码中需要加载完成后必须调用ProgressDialog的dimiss()方法关闭对话框，否则会一直存在。</p>
<h2 id="2、四种基本布局"><a href="#2、四种基本布局" class="headerlink" title="2、四种基本布局"></a>2、四种基本布局</h2><p>布局是一种可以放置很多空间的容器，可以按照一定的规律调整内部空间的位置。布局的内部出了放置控件外，也可以放置布局，通过多层布局的嵌套。  </p>
<h3 id="2-1线性布局"><a href="#2-1线性布局" class="headerlink" title="2.1线性布局"></a>2.1线性布局</h3><p>排列方向：  </p>
<pre><code>android:orientation=&quot;vertical&quot;  //垂直排列
android:orientation=&quot;horizontal&quot;  //水平排列

android:layout_gravity =  &quot;top&quot;//控件在布局中的对齐方式
</code></pre><p>线性布局中可以用比例的方式指定控件的大小android:layout_weight，设置了这个属性控件的宽度就不应该在由android:layout_width来决定。LinearLayout下所有控件指定的layout_weight相加，得到一个总值，该控件的layout_weight值除以总值就是占屏幕的宽度的大小。</p>
<h3 id="2-2相对布局"><a href="#2-2相对布局" class="headerlink" title="2.2相对布局"></a>2.2相对布局</h3><p>RelativeLayout是非常常用的布局，和LinearLayout排列规则不同，RelativeLayout更加随意，可以通过相对定位的方式让控件出现在布局的任何位置。  </p>
<pre><code>&lt;RelativeLayout  ...
    ...
    &lt;Button
        android:id=&quot;@+id/button3&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_centerInparent=&quot;true&quot;
        android:text=&quot;Button3&quot; /&gt;
      &lt;Button
        android:id=&quot;@+id/button2&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_above=&quot;@id/button3&quot; //在button3的上方
        android:layout_toLeftOf=&quot;@id/button3&quot;  //在button3的左边
        android:text=&quot;Button2&quot; /&gt;
    ...
&lt;/RelativeLayout&gt;
</code></pre><p>一个控件去引用另外一个控件的id时，该控件一定要定义在引用控件的后面，不然会出现找不到id的情况。  </p>
<h3 id="2-3帧布局"><a href="#2-3帧布局" class="headerlink" title="2.3帧布局"></a>2.3帧布局</h3><p>FrameLayout应用场景较少，所有的控件都默认摆放在布局的左上角。<br>也可以使用android:layout_gravity来指定对齐方式。  </p>
<h3 id="2-4百分比布局"><a href="#2-4百分比布局" class="headerlink" title="2.4百分比布局"></a>2.4百分比布局</h3><p>之前的布局只要LineLayout支持使用layout_weight属性来实现比例指定控件大小的功能。引入百分比布局来解决，这种布局中不再使用wrap_content、match_parent等方式指定控件大小，而是直接指定控件在布局中所占的百分比，这样可以轻松实现任意比例分割布局。<br>百分比布局只为FrameLayout和RelativeLayout进行功能扩展，提供了PercentFrameLayout和PercentRelativeLayout这两个全新布局。<br>在项目的build.gradle中添加百分比布局库的依赖就能保证百分比布局在Android所有系统版本上兼容。 </p>
<pre><code>&lt;android.support.percent.PercentFrameLayout
    ...
    &lt;Button
        ...
        app:layout_widthPercent=&quot;50%&quot;
        app:layout_heightPercent=&quot;50%&quot; /&gt;
    ...

&lt;/android.support.percent.PercentFrameLayout&gt;
</code></pre><h2 id="3、创建自定义控件"><a href="#3、创建自定义控件" class="headerlink" title="3、创建自定义控件"></a>3、创建自定义控件</h2><p>所有控件都是直接或间接继承自View，所有布局都是直接或间接继承自ViewGroup。View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，我们使用的控件就是在View的基础之上又添加各自特有的功能。  </p>
<h3 id="3-1引入布局创建控件"><a href="#3-1引入布局创建控件" class="headerlink" title="3.1引入布局创建控件"></a>3.1引入布局创建控件</h3><p>新建一个title.xml文件  </p>
<pre><code>  &lt;LinearLayout ...
    ...
    &lt;Button
        .. /&gt;
    &lt;TextView
        ... /&gt;
    ...
&lt;/LinearLayout&gt;

//部分属性说明
android:background = &quot;@drawable/edit_png&quot;//为布局或控件指定背景，可以使用颜色或图片填充
android:layout_margin = &quot;5dp&quot;//指定控件在各个方向上偏移的距离
android:layout_marginLeft或者android:layout_marginTop
</code></pre><p>在程序中使用，在activity_main.xml中添加：  </p>
<pre><code>&lt;LinearLayout ...
    ...
    &lt;include layout=&quot;@layout/title&quot;/&gt;  //include语句引入
&lt;/LinearLayout&gt;
</code></pre><h3 id="3-2创建自定义控件"><a href="#3-2创建自定义控件" class="headerlink" title="3.2创建自定义控件"></a>3.2创建自定义控件</h3><p>新建TitleLayout继承自LinearLayout，让它成为自定义的标题栏控件：  </p>
<pre><code>pulic class TitleLayout extends LinearLayout{
    public TitleLayout(Context context , AttributeSet attrs){//布局中引入TitleLayout控件就会调用这个构造函数
        super(context,attrs);
        //借助LayoutInflater实现标题栏布局多态加载，from方法构建一个LayoutInflater对象
        LayoutInflater.from(context).inflate(R.layout.title,this);//inflate方法可以多态加载一个布局文件。
        //inflate第一个参数是加载的布局文件的id，第二个参数是给加载好的布局在添加一个父布局
    }
}
</code></pre><p>创建好布局文件后，在布局文件中添加自定义控件，修改activity_main.xml中的代码：  </p>
<pre><code>&lt;LinearLayout ...
    ...
    &lt;com.example.uicustomviews.TitleLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot; /&gt;
</code></pre><p>给标题栏的按钮注册点击事件，修改TitleLayout代码：  </p>
<pre><code>pulic class TitleLayout extends LinearLayout{
    public TitleLayout(Context context , AttributeSet attrs){
        super(context,attrs);
        LayoutInflater.from(context).inflate(R.layout.title,this);
        Button titleBack =(Button)findViewByid(R.id.title_back);
        Button titleBack =(Button)findViewByid(R.ID.title_edit);
        titleBack.setOnClickListener(new OnClickListener){
            @Override
            public void onClick(View v){
                ((Activity)getContext()).finish();
            }
        };
        titleEdit.setOnClickListener(new OnClickListener){
            @Override
            public void onClick(View v){
                Toast.makeText(getContext(),&quot;You Clicked Edit button&quot;,Toast.LENGTH_SHORT).show();
            }
        };
    }
}
</code></pre><h2 id="4、滚动控件-ReyclerView-134页，未完成"><a href="#4、滚动控件-ReyclerView-134页，未完成" class="headerlink" title="4、滚动控件-ReyclerView(134页，未完成)"></a>4、滚动控件-ReyclerView(134页，未完成)</h2><p>ReyclerView也属于新增的控件，为了让RecyclerView在所有Android版本上都能使用，将其定义在support库中。在app/build.gradle文件中添加：  </p>
<pre><code>dependencies {
implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
implementation &apos;com.android.support:appcompat-v7:27.1.1&apos;
implementation &apos;com.android.support.constraint:constraint-layout:1.1.0&apos;
testImplementation &apos;junit:junit:4.12&apos;
androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos;
androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;
implementation &apos;com.android.support:recyclerview-v7:27.1.1&apos;  //添加内容
</code></pre><p>}<br>点击Sync Now进行同步。 修改activity_main.xml中的代码：  </p>
<pre><code>&lt;android.support.v7.widget.RecyclerView  //添加RecyclerView控件
    android:id=&quot;@+id/recycler_view&quot;
        android:layout_height=&quot;match_parent&quot;
    android:layout_width=&quot;match_parent&quot; /&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/05/三、UI开发工具(控件)/" data-id="ck2n3djmp001jxd6cfbrg2oen" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-二、活动(Activity)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/03/二、活动(Activity)/" class="article-date">
  <time datetime="2018-06-03T11:49:34.000Z" itemprop="datePublished">2018-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/03/二、活动(Activity)/">二、活动（Activity）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="二、活动（Activity）"><a href="#二、活动（Activity）" class="headerlink" title="二、活动（Activity）"></a>二、活动（Activity）</h1><p>活动（Activity）是一种可以包含用户界面的组件，主要用于和用户进行交互，一个应用程序可以包含零个或者多个活动。</p>
<h2 id="1、活动基本用法"><a href="#1、活动基本用法" class="headerlink" title="1、活动基本用法"></a>1、活动基本用法</h2><h3 id="1-1、手动创建活动"><a href="#1-1、手动创建活动" class="headerlink" title="1.1、手动创建活动"></a>1.1、手动创建活动</h3><p>Activity Name：FirstActivity；<br>Generate Layout File：表示会自动为FirstActivity创建一个对应的布局文件；<br>Launcher Activity：表示自动将FirstActivity设置为当前项目的主活动；<br>Backwards Compatibility：表示为项目启用向下兼容的模式。  </p>
<p>项目的任何活动都应该重写Activity的onCreate()方法，如FirstActivity中Android Studio的默认实现：  </p>
<pre><code>package com.example.xxxxx.activitytest;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;

public class FirstActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {//重写onCreate方法,主要是加载一些组件
        super.onCreate(savedInstanceState);          //调用父类的onCreate方法，参数的作用是保持
    }
}
</code></pre><h3 id="1-2、创建和加载布局"><a href="#1-2、创建和加载布局" class="headerlink" title="1.2、创建和加载布局"></a>1.2、创建和加载布局</h3><p>Android程序的设计讲究逻辑和视图分离，最好每一个活动都能对应一个布局，布局就是用来显示界面内容。  </p>
<h4 id="1-2-1创建布局"><a href="#1-2-1创建布局" class="headerlink" title="1.2.1创建布局"></a>1.2.1创建布局</h4><p>在app/src/main/res目录右击-&gt;New-&gt;Directory创建layout目录。layout目录右击-&gt;New-&gt;Layout resource file,命名布局文件为first_layout，根元素选择LinearLayout。创建完成。<br>在Android Studio的下方的Design是可视化布局编辑器，不仅可以预览当前的布局，还可以通过拖放的方式编辑布局；Text是通过XML文件的方式来编辑布局的，其代码如下：  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

&lt;/LinearLayout&gt;  
</code></pre><p>布局文件中已经有一个LinearLayout元素，添加一个按钮：  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;Button
  //android:id是给当前元素定义一个唯一标识符，代码可以对其进行操作；     //在XML中引用一个id就用@id/id_name语法；在XML中定义一个id就用@+id/id_name语法
android:id=&quot;@+id/button_1&quot;
       android:layout_width=&quot;match_parent&quot;  //当前元素宽度，match_parent表示和父元素一样宽
    android:layout_height=&quot;wrap_content&quot; //当前元素高度，wrap_content表示高度更好包含里面的内容就行
    android:text=&quot;Button 1&quot;  //指定元素中显示的文字内容
    /&gt;

&lt;/LinearLayout&gt;
</code></pre><h4 id="1-2-2在活动中加载布局"><a href="#1-2-2在活动中加载布局" class="headerlink" title="1.2.2在活动中加载布局"></a>1.2.2在活动中加载布局</h4><p>在FirstActivity中的onCreate方法中加入代码：  </p>
<pre><code>package com.example.xxxxx.activitytest;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;

public class FirstActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.first_layout);//给当前活动加载布局，一般传入布局文件的id
    }
}
</code></pre><p>项目的添加的任何资源都会在R文件中生成一个相应的资源id，first_layout.xml布局的id也添加到R文件中了，R.layout.first_layout就可以得到first_layout.xml布局的id。  </p>
<h4 id="1-2-3在AndroidManifest文件中注册"><a href="#1-2-3在AndroidManifest文件中注册" class="headerlink" title="1.2.3在AndroidManifest文件中注册"></a>1.2.3在AndroidManifest文件中注册</h4><p>所有的活动都要在AndroidManifest.xml文件中注册才能生效，FirstActivity在AndroidManifest.xml中注册过了，app/src/main/AndroidManifest.xml：  </p>
<pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        package=&quot;com.example.xxxxxx.activitytest&quot;&gt;

    &lt;application
    android:allowBackup=&quot;true&quot;
    android:icon=&quot;@mipmap/ic_launcher&quot;
    android:label=&quot;@string/app_name&quot;
    android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
    android:supportsRtl=&quot;true&quot;
    android:theme=&quot;@style/AppTheme&quot;&gt;
    &lt;activity android:name=&quot;.FirstActivity&quot;&gt;&lt;/activity&gt;
&lt;/application&gt;

&lt;/manifest&gt;
</code></pre><p>活动的注册在<application>标签内，通过<activity>注册，android:name来指定具体注册哪一个活动，.FirstActivity是一个缩写，<manifest>标签的package指定了包名。<br>仅仅注册不能运行，还需要为程序配置主活动，在AndroidManifest.xml中使用<intent-filter>标签：  </intent-filter></manifest></activity></application></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.example.xxxxx.activitytest&quot;&gt;

&lt;application
    android:allowBackup=&quot;true&quot;
    android:icon=&quot;@mipmap/ic_launcher&quot;
    android:label=&quot;@string/app_name&quot;
    android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
    android:supportsRtl=&quot;true&quot;
    android:theme=&quot;@style/AppTheme&quot;&gt;
    &lt;activity android:name=&quot;.FirstActivity&quot;
        android:label=&quot;This is FirstActivity&quot;&gt;//指定活动标题栏内容，会话顶部，还是启动器中应用程序的名称
        &lt;intent-filter&gt;  //标签内配置主活动
            &lt;action android:name = &quot;android.intent.action.MAIN&quot;/&gt;  //使用这两句声明来配置
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
&lt;/application&gt;

&lt;/manifest&gt;
</code></pre><h4 id="1-2-4在活动中使用Toast"><a href="#1-2-4在活动中使用Toast" class="headerlink" title="1.2.4在活动中使用Toast"></a>1.2.4在活动中使用Toast</h4><p>Toast是Android系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息通知给用户，这些信息一段时间后会自动消失，不会占用任何屏幕空间。<br>定义一个Toast触发点，使用界面中的按钮，在onCreate方法中添加代码：  </p>
<pre><code>package com.example.xxxxx.activitytest;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

public class FirstActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.first_layout);

    Button button1 = (Button) findViewById(R.id.button_1);//获取布局文件中定义的元素实例，first_layout.xml中通过android:id指定的
    button1.setOnClickListener(new View.OnClickListener() {//这个方法为按钮注册一个监听器，点击按钮就会执行onClick方法
        @Override
        public void onClick(View v) {//弹出Toast的功能
        //通过静态方法makeText创建Toast对象，然后调用show显示出来
        //第一个参数Context，Toast要求的上下文;第二个参数显示的文本内容；第三个参数显示时长
            Toast.makeText(FirstActivity.this,&quot;you clicked Button 1&quot;,Toast.LENGTH_SHORT).show();
        }
    });
    }
}
</code></pre><h4 id="1-2-5在活动中使用Menu"><a href="#1-2-5在活动中使用Menu" class="headerlink" title="1.2.5在活动中使用Menu"></a>1.2.5在活动中使用Menu</h4><p>使得菜单能得到展示并不占用屏幕。<br>在res目录右击-&gt;New-&gt;Directory,输入menu；文件夹下新建main菜单，menu右击-&gt;New-&gt;Menu resource file，在main.xml中添加代码：  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
        &lt;item   //item标签用来创建某一个菜单项
            android:id=&quot;@+id/add_item&quot;  //给菜单项指定一个唯一标识符
            android:title=&quot;Add&quot;/&gt;     //给菜单项指定一个名称
        &lt;item
            android:id=&quot;@+id/remove_item&quot;
            android:title=&quot;Remove&quot;/&gt;
&lt;/menu&gt;
</code></pre><p>在FirstActivity中重写onCreateOptionMenu()方法（MAC中control+O）:  </p>
<pre><code>@Override
public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.main , menu);//获得MenuInflater对象，调用inflate方法给当前活动创建菜单
//inflate()方法2个参数，第一个指定通过哪一个资源文件来创建菜单；第二个参数指定我们的菜单项添加到哪一个Menu对象中，此处使用了传入的参数
    return true;
}
</code></pre><p>要菜单真正可用，还要在定义菜单响应事件，通过在FirstActivity中重写onOptionItemSelected()方法：</p>
<pre><code>    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()){//判断点击的是哪一个菜单项
            case R.id.add_item:
            Toast.makeText(this,&quot;You clicked Add&quot;,Toast.LENGTH_SHORT).show();
            break;
           case R.id.remove_item:
                Toast.makeText(this,&quot;You clicked Remove&quot;,Toast.LENGTH_SHORT).show();
                break;
        default:
    }
    return true;
}
</code></pre><h4 id="1-2-6销毁一个活动"><a href="#1-2-6销毁一个活动" class="headerlink" title="1.2.6销毁一个活动"></a>1.2.6销毁一个活动</h4><p>除了返回键销毁活动外，在代码中销毁可以使用Activity类提供的finish()方法，例如修改按钮监听器中的代码：  </p>
<pre><code>button1.setOnClickListener(new View.OnClickListener() {
           @Override
        public void onClick(View v) {
            //Toast.makeText(FirstActivity.this,&quot;you clicked Button 1&quot;,Toast.LENGTH_SHORT).show();
            finish();
        }
    });
</code></pre><p>点击Button 1就销毁了活动。  </p>
<h2 id="2、使用Intent在活动中切换"><a href="#2、使用Intent在活动中切换" class="headerlink" title="2、使用Intent在活动中切换"></a>2、使用Intent在活动中切换</h2><p>点击启动器只会进入到应用的主活动中，所以需要从主活动跳转到其他活动。<br>Intent是Android程序中各组件交互的一种重要方式，不仅可以指明当前组件想要执行的动作，还可以在不同组件直接传递数据。一般可用于启动活动、启动服务以及发送广播等。  </p>
<h3 id="2-1使用显示Intent"><a href="#2-1使用显示Intent" class="headerlink" title="2.1使用显示Intent"></a>2.1使用显示Intent</h3><h4 id="2-1-1创建另外一个活动"><a href="#2-1-1创建另外一个活动" class="headerlink" title="2.1.1创建另外一个活动"></a>2.1.1创建另外一个活动</h4><p>右击包名-&gt;New-&gt;Activity-&gt;Empty Activity,创建SecondActivity，布局为second_layout，不选Launcher Activity。编辑second_layout.xml如下：  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

&lt;Button
    android:id=&quot;@+id/button_2&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;Button 2&quot;
    /&gt;

&lt;/LinearLayout&gt;  
</code></pre><p>任何一个活动都需要在AndroidManifest.xml中注册，Android Studio已自动完成，由于不是主活动，不需要配置<intent-filter>标签里的内容。FirstActivity和SecondActivity注册对比如下：  </intent-filter></p>
<pre><code>&lt;activity
        android:name=&quot;.FirstActivity&quot;
        android:label=&quot;This is FirstActivity&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;.SecondActivity&quot;&gt;&lt;/activity&gt;
</code></pre><h4 id="2-1-2显示Intent"><a href="#2-1-2显示Intent" class="headerlink" title="2.1.2显示Intent"></a>2.1.2显示Intent</h4><p>Intent的构造函数之一：  </p>
<pre><code>Intent(Context packageContext , Class&lt;?&gt;cls)
</code></pre><p>第一个参数表示启动活动的上下文，第二个指想要启动的目标活动。<br>Activity类中提供的一个startActivity()方法接收一个Intent参数，专门用于启动活动。修改FirstActivity中按钮的点击事件：  </p>
<pre><code>button1.setOnClickListener(new View.OnClickListener() {
       @Override
       public void onClick(View v) {
           //Toast.makeText(FirstActivity.this,&quot;you clicked Button 1&quot;,Toast.LENGTH_SHORT).show();
           Intent intent = new Intent(FirstActivity.this , SecondActivity.class);
           startActivities(intent);
       }
   });
</code></pre><h3 id="2-2隐式Intent"><a href="#2-2隐式Intent" class="headerlink" title="2.2隐式Intent"></a>2.2隐式Intent</h3><p>不明确指出想要启动哪一个活动，而是指定一系列更为抽象的action和category等信息，然后交由系统分析这个Intent。<br>通过AndroidManifest.xml文件中的<activity>标签下配置<intent-filter>的内容，指定当前活动能够响应action和category：  </intent-filter></activity></p>
<pre><code>&lt;activity android:name=&quot;.SecondActivity&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;com.example.xxxxx.activitytest.ACTION_START&quot;/&gt;
            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
</code></pre><p>只有<action>和<category>中的内容同时匹配上Intent中指定的action和category时，这个活动才响应该Intent。<br>修改FirstActivity中按钮的点击事件：  </category></action></p>
<pre><code>button1.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            //Toast.makeText(FirstActivity.this,&quot;you clicked Button 1&quot;,Toast.LENGTH_SHORT).show();
            //Intent intent = new Intent(FirstActivity.this , SecondActivity.class);
    //使用了Intent的另外一个构造函数，传递action字符串
            Intent intent = new Intent(&quot;com.example.xxxxx.activitytest.ACTION_START&quot;);
            startActivity(intent);
        }
</code></pre><p>一个Intent只能指定一个action，但是能指定多个category。在AndroidManifest.xml的<intent-filter>中添加一个category：  </intent-filter></p>
<pre><code>&lt;activity android:name=&quot;.SecondActivity&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;com.example.xxxxx.activitytest.ACTION_START&quot;/&gt;
               &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
            &lt;category android:name=&quot;android.intent.category.MY_CATEGORY&quot;/&gt;//声明自定义的category
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
</code></pre><hr>
<pre><code>       @Override
    public void onClick(View v) {
        //Toast.makeText(FirstActivity.this,&quot;you clicked Button 1&quot;,Toast.LENGTH_SHORT).show();
        //Intent intent = new Intent(FirstActivity.this , SecondActivity.class);
        Intent intent = new Intent(&quot;com.example.xxxxx.activitytest.ACTION_START&quot;);
        intent.addCategory(&quot;com.example.xxxxx.activitytest.MY_CATEGORY&quot;);//添加一个category
        startActivity(intent);
    }
});
</code></pre><h4 id="2-2-1隐式Intent的多种用法"><a href="#2-2-1隐式Intent的多种用法" class="headerlink" title="2.2.1隐式Intent的多种用法"></a>2.2.1隐式Intent的多种用法</h4><p>隐式Intent不仅可以起到自己程序内的活动，还可以起到其他程序的活动，使得Android多个应用程序之间功能共享。例如，调用系统浏览器打开网页，修改FirstActivity中按钮事件代码：  </p>
<pre><code>button1.setOnClickListener(new View.OnClickListener() {
       @Override
       public void onClick(View v) {
           Intent intent = new Intent(Intent.ACTION_VIEW);//Intent的action是Intent.ACTION_VIEW,系统内置的动作
           intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;));//Uri.parse方法将网址字符串解析成一个Uri对象，setData将对象传递进去
           startActivity(intent);
       }
   });
</code></pre><p>还可以在<intent-fileter>标签中配置<data>标签，更精确的指定当前活动响应什么类型数据。<data>标签主要可以配置以下内容：<br>android:scheme   指定数据的协议部分，如http<br>android:host    指定数据的主机部分，如<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>android:port    指定数据的端口部分<br>android:path   指定主机名和端口之后的部分<br>android:mineType   指定可以处理的数据类型，允许使用通配符方式指定<br><data>标签指定的内容和Intent携带的data完全一致时，当前活动才能够响应Intent。  </data></data></data></intent-fileter></p>
<p>拨打电话：  </p>
<pre><code> button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Intent intent = new Intent(Intent.ACTION_DIAL);
        intent.setData(Uri.parse(&quot;tel:10086&quot;));
        startActivity(intent);
    }
});
</code></pre><h3 id="2-3向下一个活动传递数据"><a href="#2-3向下一个活动传递数据" class="headerlink" title="2.3向下一个活动传递数据"></a>2.3向下一个活动传递数据</h3><p>Intent中提供了一系列putExtra()方法的重载，可以把我们需要传递的数据暂存在Intent中，启动另一个活动后，将数据从Intent中取出。例如FirstActivity中的一个字符串传递到SecondActivity中去：  </p>
<pre><code>button1.setOnClickListener(new View.OnClickListener() {
       @Override
       public void onClick(View v) {
           String data = &quot;Hello SecondActivity&quot;;
           Intent intent = new Intent(FirstActivity.this ,SecondActivity.class);
           intent.putExtra(&quot;extra_data&quot; , data); //通过putExtra传递一个字符串，第一个参数是键，用于后面从Intent中取值，data是要传的数据
           startActivity(intent);
       }
   });
</code></pre><hr>
<pre><code>//在SecondActivity中将传递的数据取出，并打印出来
public class SecondActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.second_layout);

        Intent intent = getIntent();//次方法获取用于启动SecondActivity的Intent
        String data = intent.getStringExtra(&quot;extra_data&quot;);//获取传递的数据
        Log.d(&quot;SecondActivity&quot;,data);

        }
}
</code></pre><h3 id="2-4返回数据给上一个活动"><a href="#2-4返回数据给上一个活动" class="headerlink" title="2.4返回数据给上一个活动"></a>2.4返回数据给上一个活动</h3><p>使用Activity中的一个startActivityForResult(）方法启动活动，这个方法当活动销毁时能够返回一个结果给上一个活动。两个参数，第一个参数Intent，第二个是请求码，用于在之后回调中判断数据的来源。  </p>
<pre><code>button1.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Intent intent = new Intent(FirstActivity.this ,SecondActivity.class);
            startActivityForResult(intent , 1);//请求码是唯一值就可以
    }
}
</code></pre><p>在SecondActivity中给按钮注册点击事件，并在点击事件中添加数据的逻辑：  </p>
<pre><code>public class SecondActivity extends AppCompatActivity {

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.second_layout);
   Button button2 = (Button)findViewById(R.id.button_2);
    button2.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Intent intent = new Intent();//构建一个Intent，仅仅传递数据，没指向任何“意图”
            intent.putExtra(&quot;data_rerutn&quot; , &quot;Hello FirstActivity&quot;);
            setResult(RESULT_OK,intent);//向上一活动返回数据,第一个参数返回处理结果，_OK和_CANCELED两个值，第二个参数把带有数据的intent传递回去
            finish(); //销毁当前活动
        }
    });
    }
}
</code></pre><p>startActivityForResylt()方法启动SecondActivity后，在SecondActivity被销毁后回调上一个活动的onActivityResult()方法，因此需要重写FirstActivity中的这个方法得到返回的数据：  </p>
<pre><code>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    switch (requestCode){
        case 1:
            if(resultCode == RESULT_OK){
                String returnedData = data.getStringExtra(&quot;data_return&quot;);
                Log.d(&quot;FirstActivity&quot; , returnedData);

            }
            break;
        default:
    }
}
</code></pre><p>三个参数，第一个requestCode是启动活动时传入的请求码；resultCode返回数据时传入的处理结果；data是携带返回数据的Intent。由于一个活动可能启动多个活动，每个活动返回的数据都回调到onActivityResult()方法中，因此，首先检查requestCode的值判断数据来源。  </p>
<p>还可以通过Back键回到FirstActivity，需要重写onBackPressed()方法来解决：  </p>
<pre><code>@override
public void onBackPressed(){
    Intent intent = new Intent();
    intent.putExtra(&quot;data_return&quot;,&quot;Hello FirstActivity&quot;);
    setResult(RESULT_OK,intent);
    finish();
}
</code></pre><h2 id="3、活动的生命周期"><a href="#3、活动的生命周期" class="headerlink" title="3、活动的生命周期"></a>3、活动的生命周期</h2><p>Android中的活动是可以层叠的，使用任务(Task)管理活动，一个任务就是一组存放在栈里的活动的集合，这个栈称为返回栈。启动一个新的活动就会在返回栈中入栈，处于栈顶；当调用finish()或者按back键销毁活动后就出栈。</p>
<h3 id="3-1活动状态"><a href="#3-1活动状态" class="headerlink" title="3.1活动状态"></a>3.1活动状态</h3><p><strong>运行状态：</strong>活动处于返回栈的栈顶<br><strong>暂停状态：</strong>活动不处于栈顶，但任然可见；这是因为不是每一个活动都会占满整个屏幕，暂停状态的活动仍然完全存活，如果内存极低系统会考虑回收这种活动<br><strong>停止状态：</strong>活动不处于栈顶，并且完全不可见；系统会保存相应的状态和成员变量，但是也有可能被回收<br><strong>销毁状态：</strong>活动从返回栈移除  </p>
<h3 id="3-2活动的生存期"><a href="#3-2活动的生存期" class="headerlink" title="3.2活动的生存期"></a>3.2活动的生存期</h3><p>Activity类定义了7个回调方法，覆盖生命周期的每一个环节。<br><strong>onCreate()：</strong>每个活动都要重写这个方法，会在活动第一次被创建的时候调用；在方法中完成活动的初始化，如加载布局、绑定事件<br><strong>onStart():</strong>由不可见变为可见的时候调用<br><strong>onResume()：</strong>活动准备好和用户进行交互的时候调用，此时活动处于栈顶运行状态<br><strong>onPause()：</strong>在系统准备去启动或者恢复另外一个活动的时候调用<br><strong>onStop():</strong>活动完全不可见的时候调用，如果启动的是另外一个活动是对话框式的那么执行onPause而不是onStop<br><strong>onDestroy()：</strong>活动呗销毁之前调用，之后活动变为销毁状态<br><strong>onRestart()：</strong>活动由停止活动变为运行状态前调用，活动被重新启动<br>以上方法除了onRestart方法，其他都是两两相对的，因此活动又可以分为3种生存期：<br><strong>完整生存期：</strong>活动在onCreate和onDestroy之间所经历的<br><strong>可见生存期：</strong>活动在onStart和onStop之间所经历的，此期间活动对用户总是可见<br><strong>前台生存期：</strong>活动在onResume和onPause之间所经历的，活动总是处于运行状态，可以和用户进行交互  </p>
<h3 id="3-3活动被回收了咋办"><a href="#3-3活动被回收了咋办" class="headerlink" title="3.3活动被回收了咋办"></a>3.3活动被回收了咋办</h3><p>应用场景：应用中有一个活动A，活动A启动了活动B，活动A进入停止状态，这个时候由于系统内存不足活动A被回收了，然后back键返回活动A时，活动A还是要会正常显示，此时并不会执行onRestart方法，而是会执行onCreate方法，活动A呗重新创建一次。但是，活动A中如果有一个文本框，你输入了一段文字，如果被回收了，返回到活动A时出入的文字没了。<br>为了解决这个问题，Activity中还提供了一个onSaveInstance()回调方法，这个方法可以保证还活动被回收前一定会被调用，可以通过这个方法来解决活动被回收时零时数据得不到保存的问题。  </p>
<p>onSaveInstanceState()方法携带一个Bundle类型参数。<br>Bundle提供了一系列保存数据的方法，puString() 、putInt()，每个方法2个参数，第一个参数是键，用于后面从Bundle中取值，第二个参数是真正要保存的内容。<br>MainActivity中将临时数据保存：  </p>
<pre><code>@Override
protected void onSaveInstanceState(Bundle outState){
    super.onSaveInstanceState(outState);
    String tempData = &quot;Something you just typed&quot;;
    outState.putString(&quot;data_key&quot; , tempData);
}
</code></pre><p>保存之后恢复，onCreate()方法也有一个Bundle类型参数，一般为null，如果活动被回收之前通过onSaveInstanceState()方法来保存数据，这个参数就会带有之前所保存的全部数据。修改MainActivity的onCreate()方法：  </p>
<pre><code>@Override
protected vodi onCreate(Bundle savedInstanceState){
    super.onCreate(savedInstanceState);
    Log.d(TAG , &quot;onCreate&quot;);
    setContentView(R.layout.activity_main);
    if(savedInstanceState != null){
        String tempData = savedInstanceState.getString(&quot;data_key&quot;);
        Log.d(TAG , tempData);
    }
}
</code></pre><p>取出之后就可以做相应的恢复操作，此处只是简单打印。  </p>
<h2 id="4、活动的启动模式"><a href="#4、活动的启动模式" class="headerlink" title="4、活动的启动模式"></a>4、活动的启动模式</h2><p>启动模式一共有4种：standard  singleTop  singleTask  singleInstance<br>可以在AndroidManifest.xml中通过给<activity>标签指定android:launchMode属性来选择启动模式。  </activity></p>
<h3 id="4-1standard"><a href="#4-1standard" class="headerlink" title="4.1standard"></a>4.1standard</h3><p>默认的启动模式，不显示指定的情况下，所有活动都会自动使用这种模式。使用这种模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。每当启动一个新的活动，就会在返回栈中入栈，并处于栈顶位置。</p>
<h3 id="4-2singleTop"><a href="#4-2singleTop" class="headerlink" title="4.2singleTop"></a>4.2singleTop</h3><p>启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。</p>
<h3 id="4-3singleTask"><a href="#4-3singleTask" class="headerlink" title="4.3singleTask"></a>4.3singleTask</h3><p>每次启动该活动系统只会首先在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该活动实例，并把这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。</p>
<h3 id="4-4singleInstance"><a href="#4-4singleInstance" class="headerlink" title="4.4singleInstance"></a>4.4singleInstance</h3><p>指定为singleInstance模式的活动会启动一个新的返回栈来管理这个活动。如果程序中的一个活动是允许其他程序调用的，要实现其他程序和我们的程序共享这个活动的实例，就需要这个模式创建一个单独的返回栈管理这个活动，不管哪个应用程序来访问这个活动，都共用的同一个返回栈。</p>
<h2 id="5、活动的最佳实践技巧"><a href="#5、活动的最佳实践技巧" class="headerlink" title="5、活动的最佳实践技巧"></a>5、活动的最佳实践技巧</h2><h3 id="5-1获取当前是哪一个活动"><a href="#5-1获取当前是哪一个活动" class="headerlink" title="5.1获取当前是哪一个活动"></a>5.1获取当前是哪一个活动</h3><p>在ActivityTest项目中新建一个BaseActivity类，右击包-&gt;New-&gt;Java Class，不需要注册，只需要创建普通的Java类，让BaseActivity继承自AppCompatActivity，并重写onCreate方法：  </p>
<pre><code>public class BaseActivity extends AppCompatActivity {
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.d(&quot;BaseActivity&quot; , getClass().getSimpleName());//获取当前实例的类名，通过Log打印出来
    }
}
</code></pre><p>让BaseActivity成为ActivityTest项目中所有活动的父类，继承自BaseActivity，而BaseActivity也是继承自AppCompatActivity的，所以所有活动的现有功能并不受影响。运行后每当进入一个界面，就会在Logcat中打印信息，从而知道当前界面对应哪个活动。  </p>
<h3 id="5-2随时随地退出程序"><a href="#5-2随时随地退出程序" class="headerlink" title="5.2随时随地退出程序"></a>5.2随时随地退出程序</h3><p>不需要按几次返回键退出，思路是用一个专门的集合类对所有活动进行管理。新建一个ActivityCollector类作为活动管理器：  </p>
<pre><code>public class ActivityCollector{
    public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;();//通过List暂存活动
    public static void addActivity(Activity activity){ //向List中添加活动
        activities.add(activity);
    }
    public static void removeActivity(Activity activity){//从List中移除活动
        activities.remove(activity);
    }
    public static void finishAll(){   //将List中存储的活动全部销毁
        for(Activity activity: activities){
            if(!activity.isFinishing()){
                activity.finish();
            }
        }
    }
}
</code></pre><hr>
<pre><code>//修改BaseActivity中的代码
public class BaseActivity extends AppCompatActivity {
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.d(&quot;BaseActivity&quot; , getClass().getSimpleName());
    ActivityCollector.addActivity(this);//将当前创建的活动添加到活动管理器
    }
    @Override
    protected void onDestroy(){//重写onDestroy方法
        super.onDestroy();
        ActivityCollector.removeActivity(this);//将马上销毁的活动从活动管理器中移除
    }
}
</code></pre><hr>
<pre><code>//调用ActivityCollector.finishAll()不管在什么地方都可以退出程序
public class SecondActivity extends BaseActivity {
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.second_layout);

    Button button2 = (Button)findViewById(R.id.button_2);
    button2.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
           ActivityCollector.finishAll();
        }
    });
}
</code></pre><p>}</p>
<p>保证程序完全退出可以杀掉进程：  </p>
<pre><code>android.os.Process.killProcess(android.os.Process.myPid());//myPid获取当前进程的id，killProcess只能杀掉当前程序的进程，不能用来杀掉其他程序
</code></pre><h3 id="5-3启动活动的最佳写法"><a href="#5-3启动活动的最佳写法" class="headerlink" title="5.3启动活动的最佳写法"></a>5.3启动活动的最佳写法</h3><p>一般方法通过Intent构建当前“意图”，然后调用startActivity()或者startActivityForResult()方法将活动启动，如果有数据传递使用Intent完成。如：  </p>
<pre><code>Intent intent = new Intent(FirstActivity.this , SecondActivity.class);
intent.putExtra(&quot;param1&quot; , &quot;data1&quot;);
intent.putExtra(&quot;param2&quot; , &quot;data2&quot;);
startActivity(intent);
</code></pre><p>但是有一个对接问题，你不清楚这个活动需要传递哪些数据。修改SecondActivity中代码：  </p>
<pre><code>public class SecondActivity extends BaseActivity{
    public static void actionStart(Content context , String data1 , String data2){
        Intent intent = new Intent(FirstActivity.this , SecondActivity.class);
        intent.putExtra(&quot;param1&quot; , &quot;data1&quot;);
        intent.putExtra(&quot;param2&quot; , &quot;data2&quot;);
        startActivity(intent);
    }
}
</code></pre><p>添加一个actionStart(）方法完成Intent构建，SecondActivity中需要的数据通过此方法的参数传递过来。启动SecondActivity：  </p>
<pre><code>button1.setOnClickListener(new OnClickListener){
    @Override
    public void onClick(View v){
        SecondActivity.actionStart(FirstActivity.this , &quot;data1&quot;,&quot;data2&quot;);
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/03/二、活动(Activity)/" data-id="ck2n3djn8001qxd6c9x0j70u2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-一、Android简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/03/一、Android简介/" class="article-date">
  <time datetime="2018-06-03T08:02:08.000Z" itemprop="datePublished">2018-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/03/一、Android简介/">一、Android简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、Android简介"><a href="#一、Android简介" class="headerlink" title="一、Android简介"></a>一、Android简介</h1><h2 id="1、目录文件介绍"><a href="#1、目录文件介绍" class="headerlink" title="1、目录文件介绍"></a>1、目录文件介绍</h2><h3 id="1-、Project目录下："><a href="#1-、Project目录下：" class="headerlink" title="1)、Project目录下："></a>1)、Project目录下：</h3><p>.gradle和.idea：这两个目录放置Android Studio自动生成的一些文件，无须关心，也无须编辑；<br>app ： 项目中的代码、资源等内容都是放置在这个目录；<br>build ：主要包含一些在编译时自动生成的文件，无须过多关心；<br>gradle ： 这个目录包含gradle wrapper的配置文件；<br>.gitignore ： 这个文件用来将指定的目录或文件排除在版本控制之外；<br>build.gradle：项目全局的gradle构建脚本，通常无须修改；  </p>
<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
repositories {
    google()
    jcenter()  //一个代码托管仓库，很多Android开源项目托管到jcenter上，声明之后就可以使用上面的开源项目
}
dependencies {
    classpath &apos;com.android.tools.build:gradle:3.1.2&apos;   //声明一个Gradle插件，
    // NOTE: Do not place your application dependencies here; they belong
    // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
    google()
    jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre><p>gradle.properties：这个文件是全局的gradle配置文件，这里的配置熟悉将影响到项目中所有的gradle编译脚本；<br>gradlew和gradlew.bat：这两个文件是用来在命令行界面执行gradle命令，前者是Linux或Mac系统使用，后者是Windows系统使用；<br>HelloWorld.iml：iml文件是所有Intellij IDEA项目都会自动生成的一个文件，用于标识一个Intellij IDEA项目，无须修改；<br>local.properties：这个文件用于指定本机中Android SDK路径，通常自动生成无须修改，若本机SDK路径发生变化，替换成新的路径；<br>settings.gradle：这个文件用于指定项目中所有引入的模块。  </p>
<h3 id="2-、App目录分析："><a href="#2-、App目录分析：" class="headerlink" title="2)、App目录分析："></a>2)、App目录分析：</h3><p>build：编译时自动生成的文件，无须关心；<br>libs：项目中使用到了第三方jar包，就需要将这些jar包都放在libs目录下，放在这个目录下的jar包都会被自动添加到构建路径中去；<br>androidTest：此处是用来变形AndroidTest测试用例的，可以对项目进行一些自动化测试；<br>java：放置java代码的地方；<br>res：项目中使用到的所有图片、布局、字符串等资源都要存放在这个目录下。图片放在drawable目录，布局放在layout目录，字符串放在value目录；   </p>
<pre><code>//  MyApplication程序res/values/strings.xml
&lt;resources&gt;
    &lt;string name = &quot;app_name&quot;&gt;My Application&lt;/string&gt;
&lt;/resources&gt;
//定义的字符串有2种方式引用
//1、代码中用R.string.MyApplication
//2、XML中用@string/MyAppliaction 
</code></pre><p>AndroidMainfest.xml：整个Android项目的配置文件，程序中定义的四大组件都需要在这个文件里注册，还可以在这个文件中给应用程序添加权限声明；<br>test：编写Unit Test测试用例，是对项目进行自动化测试的另一种方式；<br>.gitignore：将app模块内的指定目录或文件排除在版本控制之外；<br>app.iml：IntelliJ IDEA项目自动生成的文件；<br>build.gradle：app模块的gradle构建脚本，文件中指定很多项目构建相关的配置；  gradle是先进的项目构建工具  </p>
<pre><code>apply plugin: &apos;com.android.application&apos; //表示应用程序模块，可以直接运行，另外一个是com.android.library，需要依附于别的应用程序模块来运行

android {//这个闭包中配置项目构建中的各种属性
compileSdkVersion 27     //编译版本
defaultConfig {
    applicationId &quot;com.example.zhangqin07.myapplication&quot;
    minSdkVersion 15
    targetSdkVersion 27
    versionCode 1
    versionName &quot;1.0&quot;
    testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;
}
buildTypes { //用于指定安装文件的相关配置，一般有debug和release
    release {  //正式安装文件的配置
        minifyEnabled false   //是否对项目的代码进行混淆，true表示混淆，false表示不混淆
        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
    //用于指定混淆时的规则文件，proguard-android.txt是Android SDK目录下通用的混淆规则
    //proguard-rules.pro是当前项目的根目录下的，编写当前项目的特有混淆规则
    }
}
</code></pre><p>}</p>
<pre><code>dependencies {//这个闭包指定当前项目所有的依赖关系，本地依赖、库依赖、远程依赖
implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) //本地依赖声明，将libs目录下的所有jar后缀的 文件添加到项目的构建路径中去
implementation &apos;com.android.support:appcompat-v7:27.1.1&apos; //远程依赖，com.android.suppor域名部分，用于和其它公司库区分；appcompat-v7组名称，用于同一公司不同库区分；27.1.1版本号，同一库不同版本区分。
implementation &apos;com.android.support.constraint:constraint-layout:1.1.0&apos;
testImplementation &apos;junit:junit:4.12&apos;
androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos;
androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;
</code></pre><p>}</p>
<p>proguard-rules.pro：用于指定项目代码的混淆规则。  </p>
<h2 id="2、Android日志工具"><a href="#2、Android日志工具" class="headerlink" title="2、Android日志工具"></a>2、Android日志工具</h2><p>Android中的日志工具类是Log(Android.util.Log)，这个类有5种方法打印日志：<br>Log.v() :用于打印最琐碎、最小的日志信息，级别为verbose，Android日志最低级；<br>Log.d()：用于打印一些调试信息，级别为debug，比verbose高一级；<br>Log.i()：打印一些比较重要的数据，这些数据可以帮助分析用户行为数据，级别为info，比debug高一级；<br>Log.w()：用于打印警告信息，提示程序在这个地方可能存在潜在风险，最好去修复，级别为warm，比info高一级；<br>Log.e()：用于打印程序的错误信息，比如程序进入到了catch语句当中，当有错误信息打印出来的时候代表程序出现了严重问题，必须修复，级别为error，比warm高一级  </p>
<pre><code>public class MainActivity extends AppCompatActivity {
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    //添加一行打印日志的语句
    Log.d(&quot;MainActivity&quot;,&quot;onCreate execute&quot;);
    }
}
</code></pre><p>logcat中的输出结果如下：  </p>
<pre><code>06-03 10:44:12.695 6769-6769/com.example.XXXXX.myapplication D/MainActivity: onCreate execute
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/03/一、Android简介/" data-id="ck2n3djlv000exd6coefwa6ab" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-十二、集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/24/十二、集合/" class="article-date">
  <time datetime="2018-05-24T07:37:13.000Z" itemprop="datePublished">2018-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/24/十二、集合/">十二、集合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="十二、集合"><a href="#十二、集合" class="headerlink" title="十二、集合"></a>十二、集合</h1><h2 id="1、-Collection接口"><a href="#1、-Collection接口" class="headerlink" title="1、 Collection接口"></a>1、 Collection接口</h2><p>是List、Set、和Queue接口的父接口<br>定义了可用于操作List、Set和Queue的方法——增删改查  </p>
<h3 id="List接口及其实现类——ArrayList"><a href="#List接口及其实现类——ArrayList" class="headerlink" title="List接口及其实现类——ArrayList"></a>List接口及其实现类——ArrayList</h3><p>1）List是元素有序并且可以重复的集合，被称为序列。<br>2）List可精确的控制每个元素的插入位置，或者是删除某个位置元素。<br>3）ArrayList——数组序列，是List的一个重要实现类。<br>4）ArrayList底层是由数组实现。  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/24/十二、集合/" data-id="ck2n3djmd0019xd6c27wryti9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-十一 异常" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/21/十一 异常/" class="article-date">
  <time datetime="2018-05-21T02:21:29.000Z" itemprop="datePublished">2018-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/21/十一 异常/">十一、异常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="十一、异常"><a href="#十一、异常" class="headerlink" title="十一、异常"></a>十一、异常</h1><h2 id="1、异常分类"><a href="#1、异常分类" class="headerlink" title="1、异常分类"></a>1、异常分类</h2><p>异常对象都是派生于Throwable类的实例，所有的异常都是由Throwable继承而来，在下一层分解为两个分支：Error和Exception    </p>
<p>Error类描述了Java运行时系统的内部错误和资源耗尽错误。<br>Exception层次结构分解为两个分支，一个分支派生于RuntimeException，另一个分支包含其他异常。  </p>
<p>由程序错误导致的异常属于RuntimeException,而程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。<br>数组越界异常：ArrayIndexOutOfBoundsException<br>变量为空异常：NullPointerException  </p>
<h2 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h2><pre><code>try{
    语句组
}catch(Exception e){
    语句    
}  
</code></pre><p>1）抛出异常：  </p>
<pre><code>throws 异常；//声明异常
throw 异常对象；//抛出异常


public static void readFile() throws IOException{//readFile方法有可能存在IO异常，此处声明有可能抛出IO异常
    FileInputStream in = new FileInputStream(&quot;myfile.txt&quot;);
    int b ;
    b = in.read();
    while(b != -1){
        System.out.print((char)b);
        b = in.read()
    }
    in.close();
}
</code></pre><hr>
<pre><code>String readData(Scanner in) throws EOFException{
    ...
    while(...){
        if(!in.hasNext()){
            if(n &lt; len)
                throw new EOFException();
        }
        ...
    }
    return s;
}
</code></pre><p>2）捕获异常：  </p>
<pre><code>try{
    语句组;
}catch(异常类名  异常形式参数名){
    异常处理语句组;
}catch(异常类名  异常形式参数名){
    异常处理语句组  ;
}finally{
    异常处理语句组；
}
</code></pre><hr>
<pre><code>public void read(String filename){//读取文本，捕获异常
    try{
        InputStream in = new FileInputStream(filename);
        int b;
        while(b = in.read() != -1){
            process input
        }
    }
    catch(IOException exception){
        exception.printStackTrace();
    }
}
</code></pre><p>catch语句可以有0到多个，可以没有finally语句。    </p>
<p>在main()函数中调用readFile()  </p>
<pre><code>import java.io.*;
public class ExceptionTest{
    public static void main(String[] args){
        try{
            System.out.println(&quot;--------before-------&quot;);
            readFile();
            System.out.println(&quot;---------after---------&quot;);
        }catch(IOException e){
            System.out.println(e);
        }
    }
}
</code></pre><p>3)再次抛出异常<br>再次抛出异常的基本方法：  </p>
<pre><code>try{
    access the database
}  
catch(SQLException e){
    throw new ServletException(&quot;database error:&quot; + e.getMessage());
    //ServletException用带有异常信息文本的构造器构造
}
</code></pre><p>更好的方法如下，将原始异常设置为新异常的“原因”：  </p>
<pre><code>try{
    access database
}
catch(SQLException e){
    Throwable se = new ServletException(&quot;database error&quot;);
    se.initCause(e);
    throw se;
}
</code></pre><p>当捕获异常后，可以重新得到原始异常：  </p>
<pre><code>Throwable e = se.getCause();
</code></pre><p>记录一个异常，在将它重新抛出，不做任何改变：  </p>
<pre><code>try{
    access database
}
catch(Exception e){
    logger.log(level , message , e);
    throw e;
}
</code></pre><p>4)  带资源的try语句：  </p>
<pre><code>//try块退出时，会自动调用res.close()
try(Resource res = ...){
    work with res
}  
</code></pre><hr>
<pre><code>//这个块正常退出时，或者存在一个异常时，就好调用in.close()方法
try(Scanner in = new Scanner(new FileInputStream(&quot;/usrs/....&quot;))){
    while(in.hasNext())
        System.out.println(in.next());
}
</code></pre><p>5）Exception类<br>构造方法：  </p>
<pre><code>public Exception();  
public Exception(String message);
public Exception(String message,Throwable cause);
</code></pre><p>方法：  </p>
<pre><code>getMessage();
getCause();
printStackTrace();
</code></pre><h2 id="3、自定义异常"><a href="#3、自定义异常" class="headerlink" title="3、自定义异常"></a>3、自定义异常</h2><p>自定义异常类就是一个派生于Exception或者是Exception子类的类。<br>例如定义一个派生于IOException的类：  </p>
<pre><code>class FileFormatException extends IOException{//定义的类包含2个构造器
    public FileFormatException(){};//默认的构造器
    public FileFormatException(String gripe){//带有详细描述信息的构造器
        super(gripe);
    }
}
</code></pre><hr>
<pre><code>//抛出自定义的异常类型
String readData(BufferedReader in) throws FileFormatException{
    ...
    while(...){
        if(ch == -1)//EOF encountered{
            if(n &lt; len)
                throw new FileFormatException();
        }
        ...
    }
    return s;
}
</code></pre><h2 id="4、断言"><a href="#4、断言" class="headerlink" title="4、断言"></a>4、断言</h2><p>语法：  </p>
<pre><code>assert 条件;
//或者
assert 条件 ： 表达式;
</code></pre><hr>
<pre><code>public class Assertion{
    public static void main(String[] args){
        assert hypoenuse(3,4) == 5: &quot;算法不正确&quot;；
    }
    public static double hypoenuse(double x , double y){
        return Math.sqrt(x*x + y*y +1);
    }
}
</code></pre><h2 id="5、日志"><a href="#5、日志" class="headerlink" title="5、日志"></a>5、日志</h2><p>1)、日志系统管理的默认日志记录器：Logger.global，并可以调用info方法记录日志信息。  </p>
<pre><code>Logger.getGlobal().info(&quot;File - &gt; open menu item selected&quot;);
//记录类容如下
May 30,2018,15:02:20 PM LoggingImageViewer fileOpen
INFO: File - &gt; open menu item selected
</code></pre><p>2)、日志记录器级别<br>SEVERE  </p>
<p>WARNING  </p>
<p>INFO  </p>
<p>CONFIG  </p>
<p>FINE  </p>
<p>FINER  </p>
<p>FINEST  </p>
<p>默认情况下只记录前三个级别，可以自己设置级别：  </p>
<pre><code>logger.setLevel( Level.FINE);//可以记录FINE和更高级别的记录
Level.ALL     //开启所有级别记录
Level.OFF     //关闭所有级别记录
</code></pre><p>对所有级别有下面几种记录方法：  </p>
<pre><code>logger.warning(message);
logger.fine(message);
</code></pre><p>还可以使用log方法指定级别：  </p>
<pre><code>logger.log(Level.FINE , message);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/21/十一 异常/" data-id="ck2n3djm90011xd6c0vv10atd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-十 多线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/17/十 多线程/" class="article-date">
  <time datetime="2018-05-17T12:57:30.000Z" itemprop="datePublished">2018-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/17/十 多线程/">十、Java多线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="十、Java多线程"><a href="#十、Java多线程" class="headerlink" title="十、Java多线程"></a>十、Java多线程</h1><p>线程是系统中的最小执行单元，同一进程中有多个线程，线程共享进程的资源。<br>Java支持多线程在java.lang包中的Thread类中</p>
<h2 id="1、线程的常用方法"><a href="#1、线程的常用方法" class="headerlink" title="1、线程的常用方法"></a>1、线程的常用方法</h2><h3 id="1-线程的创建"><a href="#1-线程的创建" class="headerlink" title="1)线程的创建"></a>1)线程的创建</h3><pre><code>Thread() 
Thread(String name)
Thread(Runnable target)
Thread(Runnable target,String name)  
</code></pre><p>A、通过Thread类创建线程：  </p>
<pre><code>class MyThread extends Thread{
    public void run(){//重写Thread类中的run方法
        for(int i =0 ; i &lt; 100 ; i++)
            System.out.print(&quot; &quot;+i);
    }
}
MyThread mt = new MyThread();         //创建线程
mt.start();         //启动线程
</code></pre><p>B、通过 Thread构造方法传递Runnable对象来创建线程：  </p>
<pre><code>//Runnable的代码可以被多个线程共享，适合多个线程处理同一个资源的情况。
class MyTask implements Runnable{
    public void run(){...};
} 
MyTask mt = new MyTask();
Thread thread = new Thread(mt);     //创建线程
thread.start();       //启动线程

C、通过匿名类实现Runnable：  

new Thread(){
    public void run(){
        for(int i =0 ; i &lt; 100 ; i++)
            System.out.print(&quot; &quot;+i);
}.start();
</code></pre><p>D、Lambda表达式：  </p>
<pre><code>new Thread( ()-&gt;{...}).start();
</code></pre><h3 id="2-线程的方法"><a href="#2-线程的方法" class="headerlink" title="2)线程的方法"></a>2)线程的方法</h3><p>启动线程  </p>
<pre><code>void start()
</code></pre><p>线程休眠 </p>
<pre><code>static void sleep(long millis)
static void sleep(long millis , int nanos)
</code></pre><p>使其它线程等待当前线程终止  </p>
<pre><code>void join()
void join(long millis)
void join(long millis , int nanos)  
</code></pre><p>设置线程优先级：  </p>
<pre><code>setPriority(int priority)
MIN_PRIORITY        MAX_PRIORITY          NORM_PRIORITY
</code></pre><h3 id="3-线程种类"><a href="#3-线程种类" class="headerlink" title="3)线程种类"></a>3)线程种类</h3><p>普通线程（非Daemon线程）：只要还有普通线程，整个程序就不会结束。<br>Daemon线程（守护线程或者后台线程）：普通线程结束，后台线程自动终止。垃圾回收线程就是后台线程。<br>使用setDaemon(true);  转换为守护线程。</p>
<h2 id="2、线程状态"><a href="#2、线程状态" class="headerlink" title="2、线程状态"></a>2、线程状态</h2><p>六个线程状态：New——新创建、Runnable——可运行、Blocked——被阻塞、Waiting——等待、Timed waiting——记时等待、Terminated——被终止  </p>
<h3 id="1）新创建进程"><a href="#1）新创建进程" class="headerlink" title="1）新创建进程"></a>1）新创建进程</h3><p>在new操作符创建一个新线程时——new Thread(r)，此时线程还没有开始运行，状态为new   </p>
<h3 id="2）可运行线程"><a href="#2）可运行线程" class="headerlink" title="2）可运行线程"></a>2）可运行线程</h3><p>一旦调用start方法，线程处于runnable状态。一个可运行线程可能正在运行也可能没有运行，线程开始运行但是不必始终保持运行，取决于操作系统提供给线程的运行时间（线程调度）。  </p>
<h3 id="3）被阻塞线程和等待线程"><a href="#3）被阻塞线程和等待线程" class="headerlink" title="3）被阻塞线程和等待线程"></a>3）被阻塞线程和等待线程</h3><p>线程请求一个内部的对象锁，而该锁被其他线程持有，则该线程进入阻塞状态。<br>当线程等待另一个线程通知调度器一个条件时，自己进入等待状态。<br>有几个方法有一个超时参数，调用他们导致进入等待状态。如：Thread.sleep/Object.wait/Thread.join/Lock.tryLock/Condition.await  </p>
<h3 id="4-被终止的线程"><a href="#4-被终止的线程" class="headerlink" title="4)被终止的线程"></a>4)被终止的线程</h3><p>因为run方法正常退出而自然死亡。<br>因为一个没有捕获的异常终止了run方法而意外死亡。  </p>
<h2 id="3、线程同步"><a href="#3、线程同步" class="headerlink" title="3、线程同步"></a>3、线程同步</h2><p>引入“互斥锁”的概念，保证共享数据操作的完整性。<br>每个对象有一个“互斥锁”的标记，这个标记用来保证任一时刻只能有一个线程访问该对象。  关键字synchronized。     </p>
<h3 id="1-synchronized"><a href="#1-synchronized" class="headerlink" title="1)synchronized"></a>1)synchronized</h3><p>在线程解锁前，必须把共享变量的最新值刷新到主内存中；<br>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。   </p>
<pre><code>//线程模拟三个窗口卖5张票

class MyThread implements Runnable{
    private static int ticketCount = 5 ;  //票的总数为5
    @Override
    public void run(){
        while(ticketCount &gt; 0){
        //System.out.println(Thread.currentThread().getName()+&quot;执行，卖之前有票&quot;+ticketCount);
        //使用synchronized关键字使得ticketCount实时更新，结果正确；
        synchronized(this){ticketCount--;}
        // 但是不使用时，结果有时候不正确，和说的多个线程处理同一资源不符合
        //ticketCount--;

        System.out.println(Thread.currentThread().getName()+&quot;卖了1张票，还剩&quot;+ticketCount);
        }
    }
}

public class TicketThread{
    public static void main(String[] args) {
        //新建一个线程类的对象
        Runnable mt = new MyThread();

        //创建三个线程模拟三个卖票窗口
        Thread th1 = new Thread(mt,&quot;窗口1&quot;);
        Thread th2 = new Thread(mt,&quot;窗口2&quot;);
        Thread th3 = new Thread(mt,&quot;窗口3&quot;);

        //启动线程
        th1.start();
        th2.start();
        th3.start();
    }
}
</code></pre><p>运行的某一种结果如下：  </p>
<pre><code>窗口3卖了1张票，还剩2
窗口1卖了1张票，还剩3
窗口2卖了1张票，还剩4
窗口1卖了1张票，还剩0
窗口3卖了1张票，还剩1
</code></pre><h3 id="2）volatile"><a href="#2）volatile" class="headerlink" title="2）volatile"></a>2）volatile</h3><p>所需的编码较少，并且运行时开销也小，但是实现的功能仅是synchronize的一部分。<br>例如：假设对共享变量除了赋值之外并不完成其他操作，就可以将这些变量声明为volitale 。但是涉及到其他操作，如++不行。上面的ticketCount声明为volatile是不行的，因为后面涉及到ticketCount++操作。  </p>
<pre><code>private static volatile int ticketCount = 5;//这样处理不行，输出的值不对的可能，如下：
窗口2卖了1张票，还剩3
窗口2卖了1张票，还剩1
窗口2卖了1张票，还剩0
窗口1卖了1张票，还剩3
窗口3卖了1张票，还剩2
</code></pre><p>java.util.concurrent包及其子包，提供了一系列的工具，更好、更方便的使用线程。<br>几个实用的类：单变量、集合、Timer、线程池。  </p>
<p><strong>线程池：</strong><br>相关的类：ExecutorService接口、ThreadPoolExecutor类、Executors工具类<br>常见语法：  </p>
<pre><code>ExcutorsService pool = Executors.newCachedThreadPool();
execute(Runnable r);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/17/十 多线程/" data-id="ck2n3djm7000wxd6c8pjs6t3e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-九 接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/17/九 接口/" class="article-date">
  <time datetime="2018-05-17T05:57:31.000Z" itemprop="datePublished">2018-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/17/九 接口/">九、接口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="九、接口"><a href="#九、接口" class="headerlink" title="九、接口"></a>九、接口</h1><h2 id="1、接口定义"><a href="#1、接口定义" class="headerlink" title="1、接口定义"></a>1、接口定义</h2><p>接口可以理解为一种特殊的类，由全局常量和公共的抽象方法组成。<br>通过接口可以描述2个不同类型类之间的共同特征,如下面的SmartPhone类和Psp类是2个不同类型的类，但是具有相同的特征-玩游戏，玩游戏的特征就可以通过接口描述。  </p>
<p>接口定义：使用interface关键字    </p>
<pre><code>[修饰符]interface 接口名 [extands 父接口1，父接口2  ... ]//中括号表示接口可以多继承
{
    零个到多个常量定义 ...
    零个到多个抽象方法的定义...
}
</code></pre><hr>
<pre><code>public interface IPlayGame{
      piblic void playGame();
}
</code></pre><p>接口就是用来被继承、被实现的，修饰符一般用public  不能使用private和protected修饰接口，所以修饰符是public abstract<br>接口中定义的变量都是常量：public static final 修饰符，定义时不添加，系统也会自动添加<br>接口的方法：public abstract修饰符，定义时不添加，系统也会自动添加，接口的方法只能是抽象方法。  </p>
<h2 id="2、接口实现"><a href="#2、接口实现" class="headerlink" title="2、接口实现"></a>2、接口实现</h2><p>继承父类实现接口的语法：  </p>
<pre><code>[修饰符] class 类名 extends 父类 implements 接口1 ，接口2 ...
{
    类体部分//如果继承了抽象类，需要实现继承的抽象方法；要实现接口中定义的方法。
}
</code></pre><hr>
<pre><code>public class SmartPhone extends Telphone implements IPlayGame{//类实现了接口，就必须实现接口中的方法
      public void call(){
        System.out.println(&quot;SmartPhone use voice to call&quot;);
    }
    public void message(){
        System.out.println(&quot;SmartPhone use voice to send message&quot;);
    }
    public void playGame(){
        System.out.println(&quot;SmartPhone can play games&quot;);
    }
}
</code></pre><hr>
<pre><code>public class Psp implements IPlayGame{//定义Psp类,它和Telphone类没有任何关系，但是具体playGame的特征
    public void playGmae(){
        System.out.println(&quot;Psp can play games&quot;);
    }
</code></pre><h2 id="3、接口的使用"><a href="#3、接口的使用" class="headerlink" title="3、接口的使用"></a>3、接口的使用</h2><p>接口的引用指向一个实现了接口的对象。  </p>
<pre><code>public class Test{
    public void main(){
        IPlayGame ip1 = new SmartPhone();//接口的引用指向一个实现了接口的对象
        ip1.playGame();
        IPlayGame ip2 = new Psp();
        ip2.playGame();
    }
}
</code></pre><h2 id="4、匿名内部类实现接口"><a href="#4、匿名内部类实现接口" class="headerlink" title="4、匿名内部类实现接口"></a>4、匿名内部类实现接口</h2><pre><code>interface i = new interface(){
    public void method(){
        System.out.println(&quot;匿名内部类实现接口&quot;);
    }
}
</code></pre><hr>
<pre><code>pulic class Test{
    public static void main(){
        IPlayGame ip3 = new IPlayGame(){
            public void playGame(){
                System.out.println(&quot;匿名内部类实现接口&quot;);
            }
        };//实现以后需要“;”来结束
        ip3.playGame();
    }
}
</code></pre><p>也可以这样：  </p>
<pre><code>new IPlayGame(){
    public void playGame(){
        System.out.println(&quot;直接new接口调用方法&quot;);
    }
}.playGame();
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/17/九 接口/" data-id="ck2n3djm0000ixd6cvmx2zvfi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-八 多态" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/17/八 多态/" class="article-date">
  <time datetime="2018-05-17T02:45:39.000Z" itemprop="datePublished">2018-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/17/八 多态/">八、多态</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="八、多态"><a href="#八、多态" class="headerlink" title="八、多态"></a>八、多态</h1><p>对象的多种形态：引用的多态和方法的多态  </p>
<h2 id="1、引用的多态"><a href="#1、引用的多态" class="headerlink" title="1、引用的多态"></a>1、引用的多态</h2><p>1）父类的引用指向本类的对象<br>2）父类的引用指向子类的对象  </p>
<p><strong>注：继承是实现多态的基础</strong>  </p>
<pre><code>public calss Animal{

}
---------------------------------------------------------------
public class Dog extends Animal{

}
---------------------------------------------------------------
public class Initial{
    public static void main(){
        Animal obj1 = new Animal();//父类的引用指向本类的对象
        Animal obj2 = new Dog();//父类的引用指向子类的对象
    }
}
</code></pre><h2 id="2、方法的多态"><a href="#2、方法的多态" class="headerlink" title="2、方法的多态"></a>2、方法的多态</h2><p>1）创建本类对象时，调用的方法为本类的方法<br>2）创建子类对象时，调用的方法为子类重写的方法或者继承的方法(子类没有重写方法)  </p>
<pre><code>public calss Animal{
    public void eat(){
        System.out.println(&quot;动物会吃&quot;);
    }
}
--------------------------------------------------------------
public class Dog extends Animal{
    public void eat(){
        System.out.println(&quot;狗会吃肉&quot;);
    }
}
--------------------------------------------------------------
    public class Cat extends Animal{

}
--------------------------------------------------------------
public class Initial{
    public static void main(){
        Animal obj1 = new Animal();//父类的引用指向本类的对象
        Animal obj2 = new Dog();//父类的引用指向子类的对象
        Animal obj3 = new Cat();

        obj1.eat();//调用父类的方法
        obj2.eat();//调用子类重写的方法
        obj3.eat();//调用子类继承父类的方法
    }
}
</code></pre><p><strong>注：子类中添加了独有的方法，如Dog类中添加了watchDoor()方法，那么父类就不能调用子类独有的方法</strong>  </p>
<h2 id="3、引用类型转换"><a href="#3、引用类型转换" class="headerlink" title="3、引用类型转换"></a>3、引用类型转换</h2><p>1）向上类型转换(隐式/自动类型转换)，是小类型到大类型的转换<br>2）向下类型转换(强制类型转换)，是大类型到小类型<br>3）instanceof运算符来解决引用对象的类型，避免类型转换的安全问题  </p>
<pre><code>public class Initial{
    public static void main(){
        Dog dog = new Dog();
        Animal animal = dog;//父类的引用指向子类的对象，自动类型提升，向上类型转换
        //将父类引用转换成子类引用
        Dog dog2 = (Dog)animal;//向下类型转换，强制类型转换，存在风险
        Cat cat = (Cat)animal;//非法的，anima引用的是Dog对象，不能转换成Cat对象，编译可以，但是运行出错
        }
}
</code></pre><p>使用instanceof运算符避免类型转换的安全问题，instanceof关键字可以判断一个引用是否是某个类型或者某个类型的子类型。  </p>
<pre><code>if(animal instanceof Dog){//判断animal是否是Dog类型或者其子类型
    if(animal instanceof Dog){ //由于Dog dog =new Dog();Animal animal = dog;所以判断为真
        Dog dog = (Dog)animal;
} else{
    System.out.println(&quot;无法进行类型转换,Dog&quot;);
}

if(animal instanceof Cat){//判断animal是否是Cat类型或者其子类型
    Cat cat = (Cat)animal;
}  else{
    System.out.println(&quot;无法进行类型转换,Cat&quot;);
}
</code></pre><p>运行结果：  </p>
<pre><code>无法进行类型转换，Cat //说明可以转换成Dog类，不能转换成Cat类
</code></pre><h2 id="4、抽象类"><a href="#4、抽象类" class="headerlink" title="4、抽象类"></a>4、抽象类</h2><p>抽象类前使用abstract关键字修饰<br>应用场景：<br>1）在某些情况，某个父类只是知道其子类应该包含怎样的方法，但是无法准确知道这些子类如何实现这些方法（约束子类必须有哪些方法，并不关注子类如何去实现）<br>2）从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而设计了子类设计的随意性    </p>
<p>作用：限制规定子类必须实现某些方法，但不关注实现细节    </p>
<pre><code>public abstract calss Telphone{  //父类，抽象类，约束子类
    public abstract void call();  //抽象方法没有方法体
    public abstract void message(); 
}
</code></pre><hr>
<pre><code>public class CellPhone extends Telphone{  //子类Cellphone
    public void call(){    //必须包含的方法
        System.out.println(&quot;通过键盘拨号&quot;);
    }
    public void message(){   //必须包含的方法
        System.out.println(&quot;通过键盘发短信&quot;);
    }
} 
</code></pre><hr>
<pre><code>public class SmartPhone extends Telphone{  //子类SmartPhone
    public void call(){    //必须包含的方法
        System.out.println(&quot;通过语音拨号&quot;);
    }
    public void message(){   //必须包含的方法
        System.out.println(&quot;通过语音发短信&quot;);
    }
} 
</code></pre><hr>
<pre><code>public class Initial{
    public static void main(String[] args){
        Telphone tel1 = new CellPhone();//抽象类的父类引用指向子类对象
        tel1.call();
        tel1.message();

        Telphone tel2 = new SmartPhone();
        tel2.call();
        tel2.message();
    }
}
</code></pre><p>运行结果：  </p>
<pre><code>通过键盘拨号
通过键盘发短信
通过语音拨号
通过语音发短信
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/17/八 多态/" data-id="ck2n3djm1000lxd6cviiio60v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/使用指南/">使用指南</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/问题总结/">问题总结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 16.67px;">Android</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/使用指南/" style="font-size: 13.33px;">使用指南</a> <a href="/tags/问题总结/" style="font-size: 10px;">问题总结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/06/HEAD请求获取视频大小/">HEAD请求获取视频大小</a>
          </li>
        
          <li>
            <a href="/2019/07/23/TextView是否折叠/">TextView是否折叠</a>
          </li>
        
          <li>
            <a href="/2019/07/23/TextView动态改变字体大小/">TextView动态改变字体大小</a>
          </li>
        
          <li>
            <a href="/2019/07/18/Android消息机制之handler原理/">Android消息机制之handler原理</a>
          </li>
        
          <li>
            <a href="/2019/07/04/网上资料链接/">网上资料链接</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>