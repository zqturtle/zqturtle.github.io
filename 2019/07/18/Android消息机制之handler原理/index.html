<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Android消息机制之handler原理 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言在Android开发中因为UI更新的操作都是在主线程中执行，而网络请求等耗时操作都是在子线程中执行的，因此会遇到很多多线程切换的问题。我们的项目中使用的是RXJava + retrofit，RXJava的observeOn和subcribeOn都能很方便的切换线程。如下形式：.observeOn(AndroidSchedulers.mainThread())它本质上还是通过handler来实现">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Android消息机制之handler原理">
<meta property="og:url" content="http://yoursite.com/2019/07/18/Android消息机制之handler原理/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前言在Android开发中因为UI更新的操作都是在主线程中执行，而网络请求等耗时操作都是在子线程中执行的，因此会遇到很多多线程切换的问题。我们的项目中使用的是RXJava + retrofit，RXJava的observeOn和subcribeOn都能很方便的切换线程。如下形式：.observeOn(AndroidSchedulers.mainThread())它本质上还是通过handler来实现">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-22T12:18:57.760Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android消息机制之handler原理">
<meta name="twitter:description" content="前言在Android开发中因为UI更新的操作都是在主线程中执行，而网络请求等耗时操作都是在子线程中执行的，因此会遇到很多多线程切换的问题。我们的项目中使用的是RXJava + retrofit，RXJava的observeOn和subcribeOn都能很方便的切换线程。如下形式：.observeOn(AndroidSchedulers.mainThread())它本质上还是通过handler来实现">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Android消息机制之handler原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/Android消息机制之handler原理/" class="article-date">
  <time datetime="2019-07-18T13:17:51.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android消息机制之handler原理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Android开发中因为UI更新的操作都是在主线程中执行，而网络请求等耗时操作都是在子线程中执行的，因此会遇到很多多线程切换的问题。我们的项目中使用的是RXJava + retrofit，RXJava的observeOn和subcribeOn都能很方便的切换线程。如下形式：<br><code>.observeOn(AndroidSchedulers.mainThread())</code><br>它本质上还是通过handler来实现的。虽然用起来很方便，但是这样对于原理的学习并不是很友好，因此特意学习了下handler原理相关知识。  </p>
<h1 id="一、handler基础知识"><a href="#一、handler基础知识" class="headerlink" title="一、handler基础知识"></a>一、handler基础知识</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><ul>
<li>MainThread(主线程)：也就是UI线程，在程序启动时自动创建。  </li>
<li>工作线程：开发者自己开启的子线程，执行一些耗时操作。  </li>
<li>Handler(处理者)：线程间通信的媒介，一是添加消息到消息队列(Message Queue)，二是处理Looper(循环器)分发的消息。  </li>
<li>Message(消息):Handler处理的对象，存储需要的操作信息。  </li>
<li>Message Queue(消息队列):是一个队列，先进先出，存储Handler发送来的消息。  </li>
<li>Looper: Message Queue和Handler的通信媒介，是一个死循环，不断从Message Queue中取出消息给Handler处理。  </li>
</ul>
<h2 id="2、-对应关系"><a href="#2、-对应关系" class="headerlink" title="2、 对应关系"></a>2、 对应关系</h2><ul>
<li>一个线程(Thread)只能对应一个循环器(Looper)，可理解为一个线程维持一个消息队列(Message Queue)。  </li>
<li>一个线程(Thread)可对应多个处理者(Handler)，可理解为一个消息队列(Message Queue)中的消息可分发给多个处理者(Handler)处理。  </li>
<li>一个循环器(Looper)可对应多个处理者(Handler)。  </li>
<li>一个处理者(Handler)只能对应一个循环器(Looper)，如果对应多个循环器(Looper)，那处理消息会错乱。  </li>
</ul>
<h1 id="二、Handler基本用法"><a href="#二、Handler基本用法" class="headerlink" title="二、Handler基本用法"></a>二、Handler基本用法</h1><h2 id="1、子线程和主线程通信"><a href="#1、子线程和主线程通信" class="headerlink" title="1、子线程和主线程通信"></a>1、子线程和主线程通信</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    Button button;</span><br><span class="line">    Handler handler;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        button = findViewById(R.id.handlerSendMsg);</span><br><span class="line">        button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;  </span><br><span class="line">            //在主线程中创建一个Handler处理子线程发来的消息</span><br><span class="line">                handler = new Handler() &#123;  </span><br><span class="line">                //重写handleMessage方法，这个方法的msg参数就是从子线程传递过来的消息</span><br><span class="line">                    @Override</span><br><span class="line">                    public void handleMessage(Message msg) &#123;  </span><br><span class="line">                    //函数体中就是消息处理的逻辑，可以通过msg.what的消息标识来分别处理不同的消息逻辑</span><br><span class="line">                        Log.d(&quot;mainThread&quot;,&quot;mainThread handleMessage:  &quot; + msg.obj);</span><br><span class="line">                        Toast.makeText(MainActivity.this,&quot;mainThread handleMessage&quot; + msg.obj,Toast.LENGTH_LONG).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                childThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void childThread()&#123;  </span><br><span class="line">     //创建一个子线程</span><br><span class="line">        Thread childThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            //在子线程中通过Handler的obtainMessage获取一个Message的实例</span><br><span class="line">                Message message = handler.obtainMessage();  </span><br><span class="line">                /** </span><br><span class="line">                设置Message的属性  </span><br><span class="line">                Message.what：用来标识信息的int值，通过该值主线程能判断出来自不同地方的信息来源  </span><br><span class="line">                Message.arg1/Message.arg2：Message初始定义的用来传递int类型值的两个变量  </span><br><span class="line">                Message.obj：用来传递任何实例化对象</span><br><span class="line">                */</span><br><span class="line">                message.obj = &quot;childThread message&quot;;</span><br><span class="line">                //通过sendMessage将消息发送出去</span><br><span class="line">                handler.sendMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        childThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、两个子线程通信"><a href="#2、两个子线程通信" class="headerlink" title="2、两个子线程通信"></a>2、两个子线程通信</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    Button button;</span><br><span class="line">    Handler handler;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        button = findViewById(R.id.handlerSendMsg);</span><br><span class="line">        button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                handlerMessageInTwoThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void handlerMessageInTwoThread() &#123;</span><br><span class="line">        Thread firstThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            //在子线程中不调用Looper.prepare()会crash报错，下面会给出分析</span><br><span class="line">                //Looper.prepare();</span><br><span class="line">                handler = new Handler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void handleMessage(Message msg) &#123;</span><br><span class="line">                        Log.d(&quot;firstThread&quot;,&quot;firstThread handleMessage:  &quot; + msg.obj);                      Toast.makeText(MainActivity.this,&quot;firstThread handleMessage&quot; + msg.obj,Toast.LENGTH_LONG).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                //不调用Looper.loop()就收不到消息</span><br><span class="line">                //Looper.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread secondThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Message sendMessage = handler.obtainMessage();</span><br><span class="line">                sendMessage.obj = &quot;secondThread发送的消息&quot;;</span><br><span class="line">                Log.d(&quot;secondThread&quot;,&quot;secondThread sendMessage: &quot; + sendMessage.obj);</span><br><span class="line">                handler.sendMessage(sendMessage);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        firstThread.setName(&quot;firstThread&quot;);</span><br><span class="line">        firstThread.start();</span><br><span class="line">        secondThread.setName(&quot;secondThread&quot;);</span><br><span class="line">        secondThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不打开上面的两行注释代码，和之前的一样，那么运行会报错，报错信息如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...... E/AndroidRuntime: FATAL EXCEPTION: firstThread</span><br><span class="line">    Process: com.example.androidtest, PID: 23777</span><br><span class="line">    java.lang.RuntimeException: Can&apos;t create handler inside thread that has not called Looper.prepare()</span><br><span class="line">        at android.os.Handler.&lt;init&gt;(Handler.java:200)</span><br><span class="line">        at android.os.Handler.&lt;init&gt;(Handler.java:114)</span><br><span class="line">        at com.example.androidtest.MainActivity$3$1.&lt;init&gt;(MainActivity.java:62)</span><br><span class="line">        at com.example.androidtest.MainActivity$3.run(MainActivity.java:62)</span><br></pre></td></tr></table></figure>
<p>意思就是在firstThread中没有调用Looper.prepare()。所以，需要加上Looper.prepare()。不过也可以在firstThread中创建Handler的时候指定一个主线程的Looper。Handler的构造函数是支持带参的，其中一个构造函数如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Use the provided &#123;@link Looper&#125; instead of the default one.</span><br><span class="line">     *</span><br><span class="line">     * @param looper The looper, must not be null.</span><br><span class="line">     */</span><br><span class="line">    public Handler(Looper looper) &#123;</span><br><span class="line">        this(looper, null, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们在firstThread中创建Handler的时候可以这样：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread firstThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //Looper.prepare();  </span><br><span class="line">                //通过Looper.getMainLooper()获取主线程的Looper</span><br><span class="line">                handler = new Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void handleMessage(Message msg) &#123;</span><br><span class="line">                        Log.d(&quot;firstThread&quot;,&quot;firstThread handleMessage:  &quot; + msg.obj);</span><br><span class="line">                        Toast.makeText(MainActivity.this,&quot;firstThread handleMessage&quot; + msg.obj,Toast.LENGTH_LONG).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                //Looper.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>这里就产生了2个问题，第一，为什么主线程中不调用Looper.prepare()可以实现子线程和主线程的通信；第二，Looper.prepare()具体干了什么，为什么不调用就不能在两个子线程中通信。下面的分析主要解决这两个问题。  </p>
<h1 id="三、Handler消息机制分析"><a href="#三、Handler消息机制分析" class="headerlink" title="三、Handler消息机制分析"></a>三、Handler消息机制分析</h1><h2 id="1、主线程为什么不需要调用Looper-prepare"><a href="#1、主线程为什么不需要调用Looper-prepare" class="headerlink" title="1、主线程为什么不需要调用Looper.prepare()"></a>1、主线程为什么不需要调用Looper.prepare()</h2><p>主线程不需要调用Looper.prepare()，那么说明Android程序在启动的时候主线程中就已经做了这部分工作。这里涉及到一个问题就是Android程序的真正入口，就是ActivityThread的main()方法。<a href="https://blog.csdn.net/xu_song/article/details/81983724" target="_blank" rel="noopener">ActivityThread源码分析</a>。查看ActivityThread的main()方法源码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line"></span><br><span class="line">        // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">        // disable it here, but selectively enable it later (via</span><br><span class="line">        // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">        CloseGuard.setEnabled(false);</span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        // Set the reporter for event logging in libcore</span><br><span class="line">        EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">        // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span><br><span class="line">        // It will be in the format &quot;seq=114&quot;</span><br><span class="line">        long startSeq = 0;</span><br><span class="line">        if (args != null) &#123;</span><br><span class="line">            for (int i = args.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">                if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                    startSeq = Long.parseLong(</span><br><span class="line">                            args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        // End of event ActivityThreadMain.</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line">//可见主线程的Looper是不能退出的</span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个函数具体的分析参考上面链接，我们只关注其中和Looper相关的，可以发现有2行：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepareMainLooper();  </span><br><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure>
<p>我们继续看Looper.prepareMainLooper()这个函数里面干了什么  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Initialize the current thread as a looper, marking it as an</span><br><span class="line">     * application&apos;s main looper. The main looper for your application</span><br><span class="line">     * is created by the Android environment, so you should never need</span><br><span class="line">     * to call this function yourself.  See also: &#123;@link #prepare()&#125;</span><br><span class="line">     */</span><br><span class="line">    public static void prepareMainLooper() &#123;</span><br><span class="line">        prepare(false);</span><br><span class="line">        synchronized (Looper.class) &#123;</span><br><span class="line">            if (sMainLooper != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过注释发现就是指定主线程的looper，并且不需要自己调，系统已经做了这部分工作。这里调用的prepare(false)和我们在子线程中调用的Looper.prepare()最终调用的都是一个函数  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Looper.prepare()最终调用的是prepare(true);</span><br><span class="line">    public static void prepare() &#123;</span><br><span class="line">        prepare(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">        if (sThreadLocal.get() != null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以仅有区别就是主线程的不能退出，子线程的可以。  </p>
<h2 id="2、Looper-prepare-做了什么"><a href="#2、Looper-prepare-做了什么" class="headerlink" title="2、Looper.prepare()做了什么"></a>2、Looper.prepare()做了什么</h2><p>不管是主线程还是子线程都必须调用Looper.prepare()，那这个函数具体做了什么呢？其实就一行代码sThreadLocal.set(new Looper(quitAllowed));      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Sets the current thread&apos;s copy of this thread-local variable</span><br><span class="line">     * to the specified value.  Most subclasses will have no need to</span><br><span class="line">     * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class="line">     * method to set the values of thread-locals.</span><br><span class="line">     *</span><br><span class="line">     * @param value the value to be stored in the current thread&apos;s copy of</span><br><span class="line">     *        this thread-local.</span><br><span class="line">     */</span><br><span class="line">    public void set(T value) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的入参是一个Looper，<strong>这个Looper就是当前线程中创建的Looper(new Looper(quitAllowed))存放在了一个ThreadLocal中</strong>。其实在所有线程中创建的Looper都存放在了一个ThreadLocal中。然后在创建Handler的时候就将Handler与当前线程关联。<strong>所以，Looper.prepare()就是将当前线程创建的Looper存放在ThreadLocal中</strong>。<br>下面我们看下是如何关联：<br>例如：handler = new Handler(Looper.getMainLooper()) {…}就是将创建的handler与主线程的Looper关联。<em>我们是可以指定特定的looper，让handleMessage运行在我们想运行的线程中。</em>构造函数如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Looper looper, Callback callback, boolean async) &#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>另外一种handler = new Handler() {…},调用如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Default constructor associates this handler with the &#123;@link Looper&#125; for the</span><br><span class="line">     * current thread.</span><br><span class="line">     *</span><br><span class="line">     * If this thread does not have a looper, this handler won&apos;t be able to receive messages</span><br><span class="line">     * so an exception is thrown.</span><br><span class="line">     */  </span><br><span class="line">     //从上面注释可见如果没有looper就会抛异常，所以需要在之前调用Looper.prepare()创建一个looper</span><br><span class="line">    public Handler() &#123;</span><br><span class="line">        this(null, false);</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    //this(null, false);构造函数源码如下  </span><br><span class="line">    public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">        if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//获取和此线程关联的looper</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        if (mLooper == null) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Can&apos;t create handler inside thread &quot; + Thread.currentThread()</span><br><span class="line">                        + &quot; that has not called Looper.prepare()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    //对应的消息队列</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以在创建handler的时候是通过 mLooper = Looper.myLooper();获取到此线程关联的looper，我们看下 Looper.myLooper()这个函数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Return the Looper object associated with the current thread.  Returns</span><br><span class="line">     * null if the calling thread is not associated with a Looper.</span><br><span class="line">     */</span><br><span class="line">    public static @Nullable Looper myLooper() &#123;</span><br><span class="line">        return sThreadLocal.get();</span><br><span class="line">    &#125;   </span><br><span class="line">      </span><br><span class="line">  //get函数的源码  </span><br><span class="line">public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，就是从ThreadLocal获取关联的looper。真正获取是在get方法里，首先获取当前线程，然后从ThreadLocalMap中取获取和当前线程关联的looper，也就是在当前线程中调用Looper.prepare()时候存储的looper。  </p>
<h1 id="四、消息处理流程"><a href="#四、消息处理流程" class="headerlink" title="四、消息处理流程"></a>四、消息处理流程</h1><p>解决完之前的两个问题，接下来分析消息的处理流程，只有来消息发送、消息获取、消息处理的完整流程走完，才能实现不同线程间的通信。  </p>
<h2 id="1、消息发送"><a href="#1、消息发送" class="headerlink" title="1、消息发送"></a>1、消息发送</h2><p>从handler.sendMessage(sendMessage);一直往里面跟发现最终调用的是MessageQueue.java类中的boolean enqueueMessage(Message msg, long when)函数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;  </span><br><span class="line">//target就是创建的handler</span><br><span class="line">        if (msg.target == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (msg.isInUse()) &#123;</span><br><span class="line">            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = new IllegalStateException(</span><br><span class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            boolean needWake;</span><br><span class="line">            if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">                // New head, wake up the event queue if blocked.</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">                // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">                // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; // invariant: p == prev.next</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">            if (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Message的发送实际是放入到了Handler对应线程的MessageQueue中将Message存到了上一个Message.next上形成了一个链式的列表，同时也保证了Message列表的时序性M通过msg.when保证了时序性。所以，至此发送消息就是将消息存放在消息队列中。  </p>
<h1 id="2、获取消息"><a href="#2、获取消息" class="headerlink" title="2、获取消息"></a>2、获取消息</h1><p>如果不调用Looper.loop();Handler还是会收不到消息，这个方法就是从消息队列中(Message Queue)中获取消息。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;  </span><br><span class="line">//熟悉的味道，在分析handler构造函数的时候也会调用myLooper()获取此线程关联的looper</span><br><span class="line">        final Looper me = myLooper();</span><br><span class="line">        if (me == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">        &#125;  </span><br><span class="line">        //获取Looper对象的消息队列</span><br><span class="line">        final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        // Make sure the identity of this thread is that of the local process,</span><br><span class="line">        // and keep track of what that identity token actually is.</span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        final long ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        // Allow overriding a threshold with a system prop. e.g.</span><br><span class="line">        // adb shell &apos;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&apos;</span><br><span class="line">        final int thresholdOverride =</span><br><span class="line">                SystemProperties.getInt(&quot;log.looper.&quot;</span><br><span class="line">                        + Process.myUid() + &quot;.&quot;</span><br><span class="line">                        + Thread.currentThread().getName()</span><br><span class="line">                        + &quot;.slow&quot;, 0);</span><br><span class="line"></span><br><span class="line">        boolean slowDeliveryDetected = false;</span><br><span class="line">//死循环，从消息队列中一直取消息</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); // might block</span><br><span class="line">            if (msg == null) &#123;</span><br><span class="line">                // No message indicates that the message queue is quitting.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">            final Printer logging = me.mLogging;</span><br><span class="line">            if (logging != null) &#123;</span><br><span class="line">                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                        msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final long traceTag = me.mTraceTag;</span><br><span class="line">            long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">            long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">            if (thresholdOverride &gt; 0) &#123;</span><br><span class="line">                slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">                slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">            &#125;</span><br><span class="line">            final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0);</span><br><span class="line">            final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0);</span><br><span class="line"></span><br><span class="line">            final boolean needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">            final boolean needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">            if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">            final long dispatchEnd;</span><br><span class="line">            try &#123;  </span><br><span class="line">            //分发消息，target就是消息的handler</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (traceTag != 0) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (logSlowDelivery) &#123;</span><br><span class="line">                if (slowDeliveryDetected) &#123;</span><br><span class="line">                    if ((dispatchStart - msg.when) &lt;= 10) &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;Drained&quot;);</span><br><span class="line">                        slowDeliveryDetected = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;,</span><br><span class="line">                            msg)) &#123;</span><br><span class="line">                        // Once we write a slow delivery log, suppress until the queue drains.</span><br><span class="line">                        slowDeliveryDetected = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (logSlowDispatch) &#123;</span><br><span class="line">                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (logging != null) &#123;</span><br><span class="line">                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Make sure that during the course of dispatching the</span><br><span class="line">            // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">            final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            if (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                        + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                        + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                        + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>整个流程就是首先获取当前线程的Looper对象，然后获取Looper对象的消息队列，最后开启一个死循环，不断从消息队列中获取消息，通过消息的handler分发消息msg.target.dispatchMessage(msg)。下面看下Handler类中的这个函数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  * Handle system messages here.</span><br><span class="line">  */</span><br><span class="line"> public void dispatchMessage(Message msg) &#123;</span><br><span class="line">     if (msg.callback != null) &#123;</span><br><span class="line">         handleCallback(msg);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         if (mCallback != null) &#123;</span><br><span class="line">             if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         handleMessage(msg);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数调用handleCallback(msg)或者handleMessage(msg)处理消息。  </p>
<h2 id="3、消息处理"><a href="#3、消息处理" class="headerlink" title="3、消息处理"></a>3、消息处理</h2><p>本例中我们没有设置callback，所以直接调用的是handleMessage(msg)这个函数。也就是我们在创建handler的时候复写的方法。但是这儿有个handleCallback(msg)方法。<br>查了下资料发现这个是由于Handler发送消息的方式导致有两种方式处理消息。如果我们使用sendMessage方式发送消息，则callback为空，即回调我们复写的handleMessage方法。二另外一种方式发送消息就是post(Runnable r)方法发送消息，就会回调runnable中复写的run方法。修改我们demo中的代码使用post方法发送消息。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void handlerMessageInTwoThread() &#123;</span><br><span class="line">        Thread firstThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Looper.prepare();</span><br><span class="line">                handler = new Handler();</span><br><span class="line">                Looper.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread secondThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                final Message sendMessage = handler.obtainMessage();</span><br><span class="line">                sendMessage.obj = &quot;secondThread发送的消息&quot;;</span><br><span class="line">                Log.d(&quot;secondThread&quot;,&quot;secondThread sendMessage: &quot; + sendMessage.obj);</span><br><span class="line">                //handler.sendMessage(sendMessage);</span><br><span class="line">                handler.post(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        Toast.makeText(MainActivity.this,&quot;firstThread handleMessage&quot; + sendMessage.obj,Toast.LENGTH_LONG).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        firstThread.setName(&quot;firstThread&quot;);</span><br><span class="line">        firstThread.start();</span><br><span class="line">        secondThread.setName(&quot;secondThread&quot;);</span><br><span class="line">        secondThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在firstThread中创建了handler，并没有复写handleMessage。而是在secondThread中使用post方式发送消息并复写了Runnable的run方法来执行我们需要执行的逻辑。  </p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>总结一下，其实Handler机制并没有想象中的复杂，主要就是handler、message、message queue、looper。  </p>
<ul>
<li>handler就是对消如果在主线程中创建handler，那么这个handler就和主线程的looper关联了。如果在子线程中创建handler，就需要先调用Looper.prepare()存储此线程的Looper，然后new Handler的时候关联。当然也可以在new Handler的指定关联的looper。  </li>
<li>message就是存储传递消息的属性。  </li>
<li>message queue就是存储发送的消息，是一个链式的列表。  </li>
<li>looper就是从message queue中取出消息给handler处理。  </li>
</ul>
<p>当然handler消息机制中涉及的问题很多，例如内存泄露问题、 ThreadLocal保证线程looper的实现、Android主线程(ActivityThread)问题，这些后续陆续补充。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/18/Android消息机制之handler原理/" data-id="ck2n3djn7001pxd6cqu87yy7q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/07/23/TextView动态改变字体大小/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          TextView动态改变字体大小
        
      </div>
    </a>
  
  
    <a href="/2019/07/04/网上资料链接/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">网上资料链接</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/使用指南/">使用指南</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/问题总结/">问题总结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 16.67px;">Android</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/使用指南/" style="font-size: 13.33px;">使用指南</a> <a href="/tags/问题总结/" style="font-size: 10px;">问题总结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/06/HEAD请求获取视频大小/">HEAD请求获取视频大小</a>
          </li>
        
          <li>
            <a href="/2019/07/23/TextView是否折叠/">TextView是否折叠</a>
          </li>
        
          <li>
            <a href="/2019/07/23/TextView动态改变字体大小/">TextView动态改变字体大小</a>
          </li>
        
          <li>
            <a href="/2019/07/18/Android消息机制之handler原理/">Android消息机制之handler原理</a>
          </li>
        
          <li>
            <a href="/2019/07/04/网上资料链接/">网上资料链接</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>